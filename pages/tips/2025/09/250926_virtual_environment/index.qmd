---
title: 【renv】仮想環境を設定する【venv】
description: |
  Rは[renv]{.fira-code}、Pythonは[venv]{.fira-code}を使います。注目のuvも紹介！
date: 2025-09-26
date-modified: 2025-12-26
categories:
- R
- Python
- VSCode
- Positron
image: image/thumbnail.png
canonical-url: https://yo5uke.com/pages/tips/2025/09/250926_virtual_environment/
aliases:
- /pages/tips/250926_virtual_environment/index.html
---

:::{.callout-note}
## uvを使った仮想環境の設定方法について
Pythonの仮想環境としてvenvを紹介していますが、よりモダンかつ強力なuvを使った環境構築・パッケージ管理の方法を追記しました。  
**爆速**で環境構築ができるので、是非ご参考になさってください。
:::

## はじめに

みなさん、仮想環境、使っていらっしゃいますでしょうか。

プログラミングにおける仮想環境とは、プロジェクトごとに依存パッケージを切り分けて管理できる仕組みです。これにより、他のプロジェクトやシステム全体に影響を与えず、再現性の高い開発環境を保つことができます。研究や開発を長期に続ける上で、安定した環境を構築するために欠かせないものです。

例えば、仮想環境をしない場合とする場合で、以下のような違いがあります。

【仮想環境なし】

* 全プロジェクトで共通のRやPythonのパッケージ（同じバージョン）を使用する。
* あるプロジェクトのためにパッケージを更新すると、他のプロジェクトで動かなくなるリスクがある。
* チームで共有するとき、同じ環境を再現するのが難しい。

【仮想環境あり】

* プロジェクトごとにパッケージのバージョンを使い分ける。
* 依存関係を切り分けることで、環境が壊れるリスクを減らせる。
* 設定ファイルを共有すれば、他の人も同じ環境を簡単に再現できる。

本ページでは、これらの違いについて説明しつつ、実際に導入するためのコードも掲載しますので、仮想環境になじみのない方から、知ってはいるけど毎度どうやるんだっけ…となってしまう方までご参考にしていただければと思います。

## 仮想環境について

仮想環境のポイントは、上で書いた通りです。もう少し詳しく書きます。

例えば、3年前のRと現在のRでは、バージョンも利用できるパッケージも大きく異なります。もしRやパッケージを常に最新に保っていた場合、3年前に書いたコードがそのまま期待通りに動作するとは限りません。計算方法が変わっていたり、古い関数が削除されていたりして、過去の研究を再現できない可能性があるのです。

この点、仮想環境では「**バージョンごとに環境を保存する**」ことで問題に対応できます。例えば、あるパッケージの現在のバージョンが1.2.3だとしても、3年後には1.5.4へ更新されているかもしれません。仮想環境を使えば「このプロジェクトではバージョン1.2.3を使用していますよ」とファイルに記録し、後からその環境を再現することができるのです。

こうすることで、研究当時の環境を正確に呼び出せるため、バージョン変更に伴うトラブルを避け、長期的に安定した再現性を確保できます。

ちなみに本ページではRに関してはrenv、Pythonに関してはvenvを使用します。どちらもメジャーな仮想環境であり、これを使えていれば問題ないと思います。

Pythonに関してはcondaなど他のメジャーな仮想環境もありますが、本ページを見てくださっている方であれば個人的にはvenvで十分だと考えています。これは目的にもよりますので、興味がある方は他の仮想環境も調べてみてください。

## renv

ではRの方の説明から始めます。

renvは、R プロジェクトごとに使用するパッケージの情報を ロックファイル（`renv.lock`） に記録し、必要に応じて同じ環境を再現できるようにするパッケージです。このロックファイルが「このパッケージのバージョン1.2.3を使用していますよ」ということを保存しているということですね。

ライブラリはグローバル環境とは分離され、プロジェクト専用のフォルダに保存されます。これにより「どのパッケージを、どのバージョンで使っていたか」が明示され、数年後でも同じ環境を復元することが可能になります。

もし仮想環境を使ったことがない方であれば、今あなたが使っているのがグローバル環境です。グローバル環境でパッケージをアップデートした場合、もれなくすべてのプロジェクトでパッケージのバージョンが更新されます。renvを使用していれば、そのプロジェクトについてだけバージョンが更新されるという仕組みです。

### renvの始め方

始め方は極めて簡単です。

まずはプロジェクトを作成します。プロジェクトとは？という方であれば、RStudioユーザーの方であれば[こちら](/pages/tips/2024/05/240515_rproj/index.qmd)、Positronの方であれば[こちら](/pages/tips/2025/09/250901_positron_setting/index.qmd#project-manager)をご参考になさってください。

そしたらコンソールで以下を実行します。

``` r
# renvをまだインストールしていない場合は先にこちらを実行
# install.packages("renv")

renv::init()
```

renvを開始する、というわかりやすい関数ですね。するとワーキングディレクトリ内にrenvというフォルダと、`.Rprofile`、`renv.lock`ファイルが作成されます。これで設定やらなにやらをしていますので、ファイルは消さないようにしてください。

後は通常通り作業を進めます。パッケージのインストールや、アップデートをしても、それはこのファイル内でのみ適用されます。

### 保存の仕方

作業を一通り終えたら、ロックファイルにパッケージのバージョンを記述しないといけません（もちろん自動でやってくれます）。以下を実行してください。

``` r
renv::snapshot()
```

`Do you want to proceed? [Y/n]: `と出てきたら`Y`を入力し、`- Lockfile written to "~/yo5uke.github.io/renv.lock".`と出てきたら保存完了です。

新しいパッケージを追加したらその都度スナップショットを実行してください。ちなみにインストールしただけでは記載の対象にならず、プロジェクト内のコードで使用したパッケージのみ記載されます。この点renvは賢いですよね。

### 環境の呼び出し方

例えばPCを変更して、環境が移ったとします。すると新しい環境ではパッケージが何もインストールされていない状態です。

しかしプロジェクトをGit経由等で新しい環境に移せたら、ロックファイルがありますので、その情報をもとに必要なパッケージをインストールすることが可能です。

`renv`パッケージがインストールされていない場合はしてから、以下の関数を実行します。

``` r
# install.packages("renv")
renv::restore()
```

これでロックファイル内に記載されているパッケージが、バージョンを保ったまま新しい環境にインストールされます。これで前のPCと同じ環境が再現できるというわけです。

ちなみに新しいPCというわけではなくとも、GitHubにプロジェクトをアップロードしておけば、当然ロックファイルもGitHub上に保存されるわけですので、再度GitHubから引っ張ってくれば、ローカルから一度プロジェクトを削除しても後々再現ができるわけです。これは地味にうれしいですよね。

### まとめ

`init()`、`snapshot()`、`restore()`の3つが使えれば、renvを使いこなせていると言えるでしょう。近年は再現可能な研究への需要が高まってきていますから、Rユーザーの方はぜひrenvを使ってみてください。

## venv

Pythonは少々ややこしいと個人的に感じています^[Pythonはまだ勉強中ということもあり、マスターすれば大したことはないのかもしれません。]。

renvはR上で完結する一方、venvはPowerShellないしコマンドプロンプトを使う必要があるからです^[Macユーザーの方へは十分な説明になっていないかもしれませんが、ターミナルを使うことになると思います。]。

それでは改めてvenvについて説明します。

venvは`Python`に標準で付属している仮想環境ツールで、プロジェクトごとに独立したパッケージ環境を作成できます。

venvで作成した環境はプロジェクト内の`.venv`フォルダに保存され、そこにPython本体や必要なライブラリがインストールされます。そのため、システム全体のPythonに影響を与えることなく、プロジェクトごとにライブラリのバージョンを固定できます。

さらに、`requirements.txt`というファイルを用いれば、使用しているライブラリとそのバージョンを記録し、他の人や別の環境でも同じ構成を再現できます。これはRの`renv.lock`に相当する役割です。

### venvの始め方 {#sec-init-venv}

それではvenv環境を作る手順に移ります。

VSCodeもしくはPositronの場合、まずプロジェクト（ワークスペース）を開いたのち、`Ctrl` + `Shift` + `@`でターミナルを開きます。

開けたら、以下を入力して実行します。

``` sh
python -m venv .venv
```

これは独立したPython環境を`.venv`というフォルダに作るということを意味しており、`.venv`という名前で作成すると、VSCodeやPositronが自動的に「これを仮想環境だな」と認識し、インタープリタの候補に出してくれるので必須ではないですがおすすめです^[インタープリタというのは、使用するPythonのバージョンのようなイメージです。PCにインストールしたグローバルなPython環境と、venv環境がこの場合の選択肢です。]。

しかし、環境を作るだけでは自動でアクティベートされません（最初は自動で起動しないということです）。

VSCodeの場合方法は2つあります。1つ目は簡単で、ターミナルを新しくするということです。ターミナルの右上に`+`ボタンがありますので、これを押して新しいターミナルを開きます。すると以下のような表示が出ますので、これでアクティベートされています。

![VSCodeのターミナル](image/activate_vscode.png)

頭に`(.venv)`と表示されていれば、アクティベートされています。

2つ目は、1つ目の方法でうまくいかなかったときにも有効な方法で、ターミナルに以下を打ち込んで実行します。

``` sh
.venv/Scripts/activate
```

これでアクティベートされます^[`.venv`とは異なるフォルダ名で作成した場合はその名前に変えてください。]。上の画像と同じ表示になると思いますのでご確認ください。

Positronの場合は、ウィンドウ右上の「R 4.5.1」や「Python 3.13.7」と表示があるところからインタープリタを選択します。

![Positronのイメージ](image/venv_positron.gif)

「Venv: .venv」とあるものを選択すればvenv環境に移れます。こちらは簡単ですね。

ちなみに少し細かい話をすると、`.venv`は容量が大きい一方で、環境の再現自体は`requirements.txt`のみで担保できるため、Gitには保存せず`.gitignore`に`.venv/`と記載しておくのがよいと思います。そのため、後述しますが新しい環境では再度venv環境を作成してください。

### 保存の仕方

保存もターミナル上で行います（Pythonのコンソールではありません）。

ターミナルで以下を実行します。

``` sh
pip freeze > requirements.txt
```

これは先述の通り、`requirements.txt`というファイルにパッケージ名とバージョンを保存します。まさにロックファイルと同じような感じですが、中身を見てみると、`polars==1.33.1`のように、非常にシンプルな形で記載されています。

作業が終わったら、適宜保存してください。

### パッケージの呼び出し方

R同様、新しい環境に移行したら、この`requirements.txt`ファイルからパッケージをバージョンごと再現する必要があります。

新しい環境だとまだ`.venv`が存在しないと思うので、[前と同じ方法](#sec-init-venv)でvenv環境を作成したのち、`renv::restore()`と同じような働きをする以下のコマンドを実行します。

``` sh
pip install -r requirements.txt
```

`-r`は「ファイルに書かれたリストを読む」という意味で、これでファイル内に記載されているパッケージがまとめてインストールできます。

### まとめ

renvよりはやや複雑ですが、ターミナル上で仮想環境の作成から再現まで行うことができます。必要なのは以下の3つです。

``` sh
python -m venv .venv
pip freeze > requirements.txt
pip install -r requirements.txt
```

## uvを使ったvenv環境の構築方法

前述のvenvは標準的な方法ですが、よりモダンで強力な`uv`というツールを使った方法もあります。

uvはAstral社が開発したPythonの環境管理ツールで、裏でRust言語を使っているため非常に高速に動作します。

![[uv](https://docs.astral.sh/uv/)](image/uv_speed.svg)

### uvのインストール

まずはuvをインストールします。以下のコマンドをターミナルで実行してください。

:::{.panel-tabset}
## Mac/Linux
```sh
curl -LsSf https://astral.sh/uv/install.sh | sh
```

## Windows
```powershell
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```
:::

### まずは：pip互換モード

pipとvenvに慣れている方は、まずは従来と同じ感覚でuvを使ってみましょう！

#### 仮想環境の作成

```sh
uv venv
```

これだけでワーキングディレクトリに`.venv`フォルダが作成されます。従来の`python -m venv .venv`と同じですが、圧倒的に高速です！

#### 仮想環境の有効化

:::{.panel-tabset}
## Mac/Linux
```sh
source .venv/bin/activate
```

## Windows
```powershell
.venv\Scripts\activate
```
:::

#### パッケージのインストール

```sh
uv pip install polars
```

複数のパッケージをまとめてインストールすることもできます。

```sh
uv pip install polars duckdb pandas
```

#### requirements.txtからのインストール

従来の`requirements.txt`がある場合も、uvで簡単にインストールできます。

```sh
uv pip install -r requirements.txt
```

#### パッケージのアンインストール

```sh
uv pip uninstall polars
```

uvは通常のpipコマンドと互換性があるため、既存のワークフローにもスムーズに導入できると思います。

### より便利に：プロジェクト管理モード

ここからがuvの真骨頂とも言える使い方です。

従来の方法では、プロジェクトごとに「venv作成 → activate → パッケージインストール」という手順を踏む必要がありました。uvのプロジェクト管理機能を使えば、**この一連の流れを自動化し、環境の再現性も確保**できます。

#### プロジェクトの作成

```sh
uv init my-analysis
cd my-analysis
```

これで`my-analysis`というフォルダが作成され、以下のファイルが自動生成されます：

- `pyproject.toml`：プロジェクトの設定と依存パッケージを管理
- `.python-version`：使用するPythonバージョンを記録
- `README.md`：プロジェクトの説明
- `main.py`：サンプルスクリプト

#### パッケージの追加

```sh
uv add polars pandas matplotlib
```

このコマンドを実行すると：

1. 自動的に`.venv`フォルダが作成される（初回のみ）
2. パッケージがインストールされる
3. `pyproject.toml`に依存関係が記録される
4. `uv.lock`にバージョンが厳密に記録される

**activateコマンドは不要です！（でかい）**

開発用のパッケージ（JupyterやPytestなど）を追加する場合は`--dev`オプションを使います。

```sh
uv add --dev ipykernel pytest
```

#### スクリプトの実行

```sh
uv run python analysis.py
```

`uv run`を使えば、仮想環境を意識せずにスクリプトを実行できます。裏で自動的に`.venv`環境を使ってくれるので、activateし忘れる心配もありません！

:::{.callout-note collapse="true"}
## VSCodeでのメリット
Positronユーザーにはあまり関係ないのですが、VSCodeユーザーにとっては**神機能**だと思います。

pipの場合毎度アクティベートをするのが面倒なので、VSCodeの設定で「"python.terminal.activateEnvironment": true」にして自動アクティベートを有効にし、`source .venv/bin/activate`を自動で実行しているのですが、困ったことにRのターミナルを開いたときにも走ってしまい、当然Rの関数でも何でもないのでエラーが出ます。別にただエラーが起きるだけなので無視しておけばよいのですが、気持ち悪さがありました。

しかしuvを使えばvenvを気にする必要がありませんから、「"python.terminal.activateEnvironment": false」にしておけば自動アクティベートされず、当然Rのターミナルでもエラーが出なくなり、気分爽快です。

そもそもVSCodeでRを使っている人自体少ないと思うのですが、もし使っている方がいらっしゃればぜひお試しください。
:::

#### Jupyter Notebookとの連携

Jupyter Notebookで分析する場合は、以下のようにします。

```sh
# jupyterを追加
uv add jupyter

# Jupyter Labを起動
uv run --with jupyter jupyter lab
```

これでブラウザが立ち上がりJupyter Labが使えます。

Jupyter Notebook内でパッケージを新たにインストールする場合には注意が必要ですが、PowerShell/ターミナルで`uv add`をすれば問題ありませんので、基本的にインストールする場合はそちらを使いましょう。

Jupyter LabではなくPositron/VSCode上で`.ipynb`ファイルを編集する場合は、ファイル内右上の「カーネルの選択」よりプロジェクトの仮想環境を選択してください。

![「Uv: プロジェクト名」と書いてあるものを選びます](image/kernel.png)

#### 環境の共有と再現

プロジェクト管理モードの最大の利点は**再現性**です。

プロジェクトを作成した場合：

```sh
# プロジェクト作成
uv init my-analysis
cd my-analysis

# パッケージ追加
uv add geopandas polars statsmodels matplotlib

# Gitにコミット（.venvはコミットしないように注意）
git add pyproject.toml uv.lock .python-version
git commit -m "Initialize project"
git push
```

Gitの操作はVSCodeやPositronのGit機能を使っても全く問題ありません。

共同研究者のPCなど、別のPCで同じ環境を再現する場合：

```sh
# プロジェクトをクローン
git clone your-repository
cd my-analysis

# 環境を完全再現
uv sync

# すぐに実行可能
uv run python analysis.py
```

`uv sync`コマンドは`uv.lock`ファイルを読み込んで、全く同じバージョンのパッケージをインストールします。これにより再現性が担保され、チーム全員が同じ環境で作業できます。

#### パッケージの削除

```sh
uv remove polars
```

`pyproject.toml`と`uv.lock`から自動的に削除され、`.venv`からもアンインストールされます。

### 2つの方法の比較

| 項目 | pip互換モード | プロジェクト管理モード（推奨） |
|------|-------------|--------------------------|
| 仮想環境作成 | `uv venv` | 自動作成 |
| 環境の有効化 | `source .venv/bin/activate` | 不要（`uv run`が自動処理） |
| パッケージ追加 | `uv pip install <pkg>` | `uv add <pkg>` |
| 依存関係の記録 | 手動（`requirements.txt`） | 自動（`pyproject.toml`+`uv.lock`） |
| 環境の再現 | `uv pip install -r requirements.txt` | `uv sync` |
| 適している場面 | 既存のpipワークフローを維持したい | 新規プロジェクト、チーム開発、再現性重視 |

**研究や分析用途では、プロジェクト管理モードがおすすめです！**爆速＆楽なので、ぜひ試してみてください。

### uvを使うメリット

uvを使うことで以下のようなメリットがあります：

#### 1. 圧倒的な再現性

`uv.lock`ファイルにより、プロジェクトの依存関係が厳密に記録されます。これにより：

- チーム全員が完全に同じ環境を構築可能
- 数ヶ月後・数年後でも同じ環境を再現可能
- 査読者や同僚が結果を検証しやすい

研究の透明性と信頼性を高める上で、非常に重要な機能かと思います。

#### 2. 高速なインストール

Rustで実装されているため、pipと比べて**10〜100倍高速**にパッケージをインストールできます。

大規模なデータ分析プロジェクトでは、セットアップ時間を大幅に短縮できます。

#### 3. 環境管理が楽

`uv run`を使えば、activateコマンドを意識する必要がありません。プロジェクト間の切り替えもスムーズです。

#### 4. Pythonバージョンも管理可能

```sh
# Python 3.12をインストール
uv python install 3.12

# プロジェクトで使用するバージョンを固定
uv python pin 3.12
```

pyenvなどの別ツールが不要で、uvだけで完結します。

### どちらの方法を選ぶべき？

- **既存プロジェクトで、すでにpip + venvのワークフローが確立している** → pip互換モードで試してみる
- **新しい分析プロジェクトを始める** → プロジェクト管理モードを使う
- **チームで開発する、または環境を共有する** → プロジェクト管理モード
- **論文の再現性を確保したい** → プロジェクト管理モード

まずはpip互換モードで速度の違いを体感し、慣れてきたらプロジェクト管理モードに移行するのがおすすめです！

詳細は[公式ドキュメント](https://docs.astral.sh/uv/)をご参照ください。

:::{.callout-tip}
## 参考
[uv](https://docs.astral.sh/uv/) - 公式ドキュメント
:::

## まとめ

今回は仮想環境のrenvとvenvについて簡単にご紹介しました。簡単にとはいうものの、エンジニアでもなければこれで十分ではないかと思っています。

仮想環境を活用しながら、再現可能な研究を進めていきましょう！

（余談：最近Geminiがすごいということで1か月だけ有料プランを試してみました。コードに関してはClaudeの方が優れていると感じましたが、サムネイルをいい感じに作ってくれて満足です笑）