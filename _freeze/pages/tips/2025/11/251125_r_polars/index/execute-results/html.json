{
  "hash": "cefb9776780006503a794be30a5f584e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"【R】[polars]{.fira-code}でデータ処理を高速化する\"\ndescription: |\n  Rustベースの高速データ処理ライブラリ{polars}をRで使う方法と、tidyverseライクに使える{tidypolars}について解説します。\ndate: 2025-11-25\ncategories:\n  - R\n  - データ処理\n---\n\n## はじめに\n\nRでデータ処理を行う際、メモリ不足や処理速度の問題に悩まされることがあります。特に大規模データを扱う場合、{tidyverse}の関数だけでは限界を感じることも少なくありません。\n\nそこで注目されているのが**{polars}**です。{polars}はRustで書かれた高速なデータフレームライブラリで、大規模データの処理を効率的に行うことができます。この記事では、Rで{polars}を使う方法と、tidyverseの文法で使える{tidypolars}について解説します。\n\n## polarsとは\n\npolarsは、Rustで実装されたデータフレームライブラリです。Pythonでよく知られていますが、R版も提供されており、以下のような特徴があります：\n\n- **高速な処理**: Rustベースで実装されており、{dplyr}や{data.table}よりも高速\n- **遅延評価**: クエリを最適化してから実行するため、効率的\n- **メモリ効率**: 列指向フォーマットのApache Arrowを内部で使用\n- **並列処理**: マルチコアを活用した並列処理が自動的に行われる\n\n{polars}の独自の文法は、メソッドチェーンを使ったものですが、{tidyverse}に慣れた人には少し馴染みにくいかもしれません。そこで登場するのが{tidypolars}です。\n\n## インストール\n\n### polarsのインストール\n\n{polars}はCRANにはまだ登録されていないため、以下のコマンドでインストールします。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(NOT_CRAN = \"true\")\ninstall.packages(\"polars\", repos = \"https://community.r-multiverse.org\")\n\n# または開発版\n# install.packages('polars', repos = c(\"https://rpolars.r-universe.dev\", \"https://cloud.r-project.org\"))\n```\n:::\n\n\n### tidypolarsのインストール\n\n{tidypolars}もCRANには登録されていないため、同様にインストールします。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(NOT_CRAN = \"true\")\ninstall.packages(\"tidypolars\", repos = c(\"https://community.r-multiverse.org\", \"https://cloud.r-project.org\"))\n\n# または開発版\n# pak::pak(\"etiennebacher/tidypolars\")\n```\n:::\n\n\n## polarsの基本的な使い方\n\nまずはpolars本来の文法で基本的な使い方を見ていきます。\n\nそもそも{polars}はPythonで一般的に使われており、R版はそのラッパーとして提供されています。Rで使う場合も、Python版と似たようなメソッドチェーンのスタイルを採用しています。\n\nPythonの場合は`import polars as pl`として`pl.read_csv()`のように使いますが、Rでは`pl$read_csv()`のように`$`でアクセスします。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(polars)\n\n# データの読み込み（CSVファイルから）\ndf <- pl$read_csv(here::here(\"data/251125_r_polars/data.csv\"))\n\n# 遅延評価を使う場合（LazyFrame）\nlf <- pl$scan_csv(here::here(\"data/251125_r_polars/data.csv\"))\n\n# データ処理の例\nresult <- lf$\n  filter(pl$col(\"age\") > 30)$\n  select(c(\"name\", \"age\", \"city\"))$\n  group_by(\"city\")$\n  agg(pl$col(\"age\")$mean())$\n  collect() # ここで初めて実行される\n\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nshape: (4, 2)\n┌─────────┬───────────┐\n│ city    ┆ age       │\n│ ---     ┆ ---       │\n│ str     ┆ f64       │\n╞═════════╪═══════════╡\n│ Fukuoka ┆ 36.0      │\n│ Osaka   ┆ 39.666667 │\n│ Tokyo   ┆ 42.25     │\n│ Nagoya  ┆ 39.0      │\n└─────────┴───────────┘\n```\n\n\n:::\n:::\n\n\n### 主な関数\n\n- `pl$read_csv()`: CSVファイルを即座に読み込む（Eager evaluation）\n- `pl$scan_csv()`: CSVファイルをスキャンする（Lazy evaluation）\n- `filter()`: 行のフィルタリング\n- `select()`: 列の選択\n- `group_by()`: グループ化\n- `agg()`: 集計\n- `collect()`: 遅延評価の結果を取得\n\n## tidypolarsで使いやすく\n\n{tidypolars}を使うと、{polars}の高速性を保ちながら、{tidyverse}の文法で書くことができます。\n\nここでは例として、irisデータセットを使って{tidypolars}の基本的な使い方を見ていきます^[`iris.csv`はデフォルトで使える`iris`データフレームをCSV化しただけです。]。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidypolars)\nlibrary(tidyverse)\n\n# データの読み込み\ndf <- read_csv_polars(here::here(\"data/iris.csv\"))\n\nresult <- df |>\n  filter(Sepal.Length > 5.0) |>\n  select(Sepal.Length, Sepal.Width, Species) |>\n  group_by(Species) |>\n  summarise(\n    avg_sepal_length = mean(Sepal.Length),\n    avg_sepal_width = mean(Sepal.Width)\n  )\n\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nshape: (3, 3)\n┌────────────┬──────────────────┬─────────────────┐\n│ Species    ┆ avg_sepal_length ┆ avg_sepal_width │\n│ ---        ┆ ---              ┆ ---             │\n│ str        ┆ f64              ┆ f64             │\n╞════════════╪══════════════════╪═════════════════╡\n│ versicolor ┆ 5.997872         ┆ 2.804255        │\n│ virginica  ┆ 6.622449         ┆ 2.983673        │\n│ setosa     ┆ 5.313636         ┆ 3.713636        │\n└────────────┴──────────────────┴─────────────────┘\n```\n\n\n:::\n:::\n\n\n### tidypolarsの利点\n\n1. **tidyverseの文法が使える**: {dplyr}に慣れている人はすぐに使える\n2. **高速性は維持**: 内部的には{polars}のエンジンを使用\n3. **学習コストが低い**: 新しい文法を覚える必要がない\n\n### 対応している関数\n\n{tidypolars}は{dplyr}および{tidyr}のS3メソッドとして実装されているため、**これらのパッケージを読み込む必要があります**（{tidyverse}を一緒に読み込んでおけば安心です！）。\nこの点を踏まえた上で、{tidypolars}では以下の主要な動詞がサポートされています：\n\n- `filter()`: 行のフィルタリング\n- `select()`: 列の選択\n- `mutate()`: 列の追加・変更\n- `summarise()` / `summarize()`: 集計\n- `arrange()`: 並び替え\n- `group_by()`: グループ化\n- `left_join()`, `inner_join()`など: 結合操作\n\n### DataFrameとLazyFrameの使い分け\n\n{tidypolars}では、2つのデータ読み込み方法があります：\n\n**DataFrame（即座に評価）**\n\n```r\n# データを即座に読み込む\ndf <- read_csv_polars(\"data.csv\")\n```\n\n- 小〜中規模データに適している\n- 即座に結果を確認できる\n- メモリに全データが読み込まれる\n\n**LazyFrame（遅延評価）**\n\n```r\n# データをスキャンするだけで、まだ読み込まれない\nlf <- scan_csv_polars(\"data.csv\")\n\nresult <- lf |>\n  filter(...) |> \n  collect()\n```\n\n- 大規模データに適している  \n- クエリ最適化の恩恵を受けられる\n- 必要な部分だけメモリに読み込む\n\n大規模データの場合は**LazyFrameを使うことを推奨**します。この場合は、最後に`collect()`を呼び出して結果を取得してください。\n\n## 実践例\n\n### 例1: 大規模CSVファイルの処理\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidypolars)\nlibrary(tidyverse)\n\n# 大規模CSVファイルを効率的に処理\nresult <- read_csv_polars(here::here(\"data/251125_r_polars/large_dataset.csv\")) |>\n  filter(!is.na(value)) |>\n  mutate(\n    value_log = log(value),\n    value_category = case_when(\n      value < 100 ~ \"small\",\n      value < 1000 ~ \"medium\",\n      TRUE ~ \"large\"\n    )\n  ) |>\n  summarise(\n    count = n(),\n    mean_value = mean(value),\n    median_value = median(value),\n    .by = value_category\n  ) |>\n  arrange(desc(mean_value))\n\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nshape: (3, 4)\n┌────────────────┬───────┬────────────┬──────────────┐\n│ value_category ┆ count ┆ mean_value ┆ median_value │\n│ ---            ┆ ---   ┆ ---        ┆ ---          │\n│ str            ┆ u32   ┆ f64        ┆ f64          │\n╞════════════════╪═══════╪════════════╪══════════════╡\n│ large          ┆ 4     ┆ 1100.0     ┆ 1075.0       │\n│ medium         ┆ 31    ┆ 472.741935 ┆ 490.0        │\n│ small          ┆ 15    ┆ 79.6       ┆ 82.0         │\n└────────────────┴───────┴────────────┴──────────────┘\n```\n\n\n:::\n:::\n\n\n### 例2: データの書き出し\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 処理結果をParquet形式で保存\nresult |>\n  write_parquet_polars(\"output/result.parquet\")\n\n# 処理結果をCSV形式で保存\nresult |>\n  write_csv_polars(\"output/result.csv\")\n```\n:::\n\n\nParquet形式については以下の記事もご覧ください。\n\n:::{.callout-tip appearance=\"minimal\"}\n[Parquetファイルについて調べてみる](/pages/blog/2025/07/250728_parquet/index.qmd)\n:::\n\n## polarsとtidyverseの使い分け\n\n### polars/tidypolarsの使用が適しているケース\n\n- **大規模データ**: 数百MB以上のデータを扱う場合\n- **処理速度が重要**: パフォーマンスが求められる場合\n- **メモリ制限**: メモリが限られている環境での処理\n\n## 注意点\n\n### tidypolarsの制約\n\n{tidypolars}は{polars}のラッパーなので、一部の{dplyr}/{tidyr}機能は未対応です：\n\n- `rowwise()`を使った行ごとの操作\n- 一部の複雑なウィンドウ関数\n- カスタム関数の中での一部の集計関数\n\nただし、`across()`、`pivot_longer()`、`pivot_wider()`などの主要な関数は**サポートされています**。\n\n### データ型の違い\n\n{polars}とRのデータフレームでは、データ型の扱いが異なる場合があります。必要に応じて`as.data.frame()`で通常のデータフレームに変換してください。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# polarsのDataFrameをRのdata.frameに変換\ndf_r <- as.data.frame(df_polars)\n\n# tibbleに変換する場合\ndf_tibble <- tibble::as_tibble(df_polars)\n\n# または collect() を使う方法（LazyFrameの場合）\ndf_r <- df_polars |>\n  collect() |> # まずDataFrameに変換\n  as.data.frame() # 次にR data.frameに変換\n```\n:::\n\n\n## おわりに\n\nこの記事では、Rで{polars}を使う方法と、tidyverseライクな文法で使える{tidypolars}について解説しました。\n\n大規模データを扱う際は、{polars}の高速性が大きなメリットになります。特に{tidypolars}を使えば、既存の{tidyverse}の知識を活かしながら高速なデータ処理が実現できます。\n\nすべてのケースで{polars}が最適とは限りませんが、データサイズや処理内容に応じて、{tidyverse}や{polars}などを使い分けることが重要だと思います。\n\nぜひ{polars}を試してみてください！\n\n## 参考\n\n:::{.callout-tip appearance=\"minimal\"}\n- [polars - R package](https://pola-rs.github.io/r-polars/)\n- [tidypolars](https://github.com/etiennebacher/tidypolars)\n- [Polars User Guide](https://pola-rs.github.io/polars-book/)\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}