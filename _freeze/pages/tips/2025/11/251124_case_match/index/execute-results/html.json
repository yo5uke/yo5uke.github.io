{
  "hash": "1f66b2ad2e06a0b3a336faba14b5c745",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"【R】[case_match()]{.fira-code}でデータフレームの中身を置き換える\"\ndescription: |\n  dplyrのcase_match()関数を使ったデータ置き換えの方法を、実務で使える例とともに解説します。\ndate: 2025-11-25\ncategories:\n  - R\n  - データ処理\n---\n\n## はじめに\n\nこの記事では、`dplyr`パッケージの`case_match()`関数を使ったデータの置き換え方法について解説します。\n\n以前「[[recode]{.fira-code}関数でデータフレームの中身を置き換える](/pages/tips/2025/07/250727_recode/index.qmd)」という記事で`recode()`関数を紹介しましたが、現在`recode()`はsuperseded（推奨されない・代替がある）となっています。そこで、より効率的な書き方として`case_match()`関数の使い方をまとめます。\n\n## [dplyr::case_match()]{.fira-code}の基本\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndf <- tibble(\n  x = c(1, 2, 3, 4, 5)\n)\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 1\n      x\n  <dbl>\n1     1\n2     2\n3     3\n4     4\n5     5\n```\n\n\n:::\n:::\n\n\n`case_match()`関数は、指定した列の値に基づいて新しい値を割り当てることができます。\n\n例えば、`x`列の値が1, 2, 3の場合は\"A\"、4, 5の場合は\"B\"という新しい列`y`を作成する場合、以下のように書きます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df |>\n  mutate(\n    y = case_match(x, c(1, 2, 3) ~ \"A\", c(4, 5) ~ \"B\")\n  )\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n      x y    \n  <dbl> <chr>\n1     1 A    \n2     2 A    \n3     3 A    \n4     4 B    \n5     5 B    \n```\n\n\n:::\n:::\n\n\n似たような関数に`case_when()`がありますが、`case_when()`は複数の条件式を評価して条件に応じた値を返すのに対して、`case_match()`は1つの変数に着目したうえで値を置き換えるという働きをします。\n\n### 例：文字列の置き換え（都道府県コードから地域名へ）\n\n実務ではよく、コードを人間が読みやすい形に変換することがあります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 都道府県コードから地方名へ変換\nprefecture_df <- tibble(\n  pref_code = c(\"01\", \"13\", \"27\", \"40\", \"47\")\n)\n\nprefecture_df <- prefecture_df |>\n  mutate(\n    region = case_match(\n      pref_code,\n      \"01\" ~ \"北海道\",\n      c(\"02\", \"03\", \"04\", \"05\", \"06\", \"07\") ~ \"東北\",\n      c(\"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\") ~ \"関東\",\n      c(\"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\") ~ \"近畿\",\n      c(\"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\") ~ \"九州・沖縄\",\n      .default = \"その他\"\n    )\n  )\n\nprint(prefecture_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  pref_code region    \n  <chr>     <chr>     \n1 01        北海道    \n2 13        関東      \n3 27        近畿      \n4 40        九州・沖縄\n5 47        九州・沖縄\n```\n\n\n:::\n:::\n\n\n`.default`引数を使うことで、マッチしなかった値にデフォルト値を割り当てることができます。\n\n### 名前付きベクトルを使った方法\n\nマッピングルールが複雑な場合や再利用したい場合は、あらかじめ名前付きベクトルを定義しておくと便利です。\n\nただ、この場合は以前紹介したような`dplyr::recode()`ではなく、今回の`case_match()`でもなく、名前付きベクトルを`[]`でインデックス参照する方法で解決できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 商品カテゴリコードから日本語名へのマッピングを定義\ncategory_mapping <- c(\n  \"A\" = \"食品\",\n  \"B\" = \"衣料品\",\n  \"C\" = \"家電\",\n  \"D\" = \"書籍\",\n  \"E\" = \"その他\"\n)\n\nproduct_df <- tibble(\n  product_id = 1:6,\n  category_code = c(\"A\", \"B\", \"C\", \"A\", \"D\", \"F\")\n)\n\n# 方法1: 名前付きベクトルを使ってインデックス参照\nproduct_df <- product_df |>\n  mutate(\n    category_name = category_mapping[category_code],\n    category_name = if_else(is.na(category_name), \"未分類\", category_name)\n  )\n\nprint(product_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  product_id category_code category_name\n       <int> <chr>         <chr>        \n1          1 A             食品         \n2          2 B             衣料品       \n3          3 C             家電         \n4          4 A             食品         \n5          5 D             書籍         \n6          6 F             未分類       \n```\n\n\n:::\n:::\n\n\n意外にも簡単でした。\n\n名前付きベクトルを`[]`でインデックス参照することで、キーから値への変換が簡潔に書けます。マッチしない値は`NA`になるため、`if_else()`でデフォルト値を設定します^[全部マッチすることがわかっているなら2行目は要りません。]。この方法は、マッピングルールが多い場合や、複数の場所で同じマッピングを使いたい場合に特に有効です。\n\n#### 逆引きマッピング\n\n今度は同じ`category_mapping`を使って、カテゴリ名からカテゴリコードへの逆引きマッピングを行う方法についてまとめます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 逆引きマッピング用の名前付きベクトルを作成\nreverse_mapping <- setNames(names(category_mapping), category_mapping)\n\ndf <- tibble(\n  category_name = c(\"食品\", \"家電\", \"書籍\", \"未分類\")\n)\n\ndf <- df |>\n  mutate(\n    category_code = reverse_mapping[category_name],\n    category_code = if_else(is.na(category_code), \"不明\", category_code)\n  )\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  category_name category_code\n  <chr>         <chr>        \n1 食品          A            \n2 家電          C            \n3 書籍          D            \n4 未分類        不明         \n```\n\n\n:::\n:::\n\n\nここでは`setNames()`関数を使って、元の`category_mapping`の名前と値を入れ替えた新しい名前付きベクトル`reverse_mapping`を作成しています。\n\nその後、同様に`[]`でインデックス参照を使ってカテゴリ名からカテゴリコードへの変換を行い、マッチしない場合は`if_else()`でデフォルト値を設定しています^[ここも同様に全部マッチすることがわかっているなら2行目は要りません。]。\n\n:::{.callout-note collapse=\"true\"}\n## [setNames()]{.fira-code}の動き\n\n`setNames()`関数は、ベクトルに名前を付けるための関数です。以下のように使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nsetNames(x, c(\"a\", \"b\", \"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c \n1 2 3 \n```\n\n\n:::\n\n```{.r .cell-code}\n# 結果:\n#  a b c\n#  1 2 3\n```\n:::\n\n\nこの例では、数値ベクトル`x`に対して、名前ベクトル`c(\"a\", \"b\", \"c\")`を使って名前を付けています。結果として、`x`の各要素に対応する名前が付与されます。\n\nさらに今回のように`names()`では`A`, `B`, `C`などの名前を取得し、それに対応する値を逆に設定する^[ここもややこしい点ですが、`category_mapping`はA→食品、B→衣料品のように対応関係が含まれているものの、値は\"食品\"や\"衣料品\"の方に該当します。データフレームのような感じで、\"A\"や\"B\"は列名、\"食品\"や\"衣料品\"は値、というイメージを持っていただければと思います。]ことで、逆引きマッピング用の名前付きベクトルを作成できます。\n\n特に長いマッピングルールを扱う場合に、また1から名前付きベクトルを作成しなくてよくなるため便利だと思います。\n:::\n\n## おわりに\n\nこの記事では、`dplyr::case_match()`を使ったデータの置き換え方法について解説しました。\n\n`case_match()`は単一の列の値を置き換える際に直感的で読みやすいコードが書けます。また、名前付きベクトルを使ったインデックス参照を組み合わせることで、複雑なマッピングルールも効率的に管理できます。\n\nデータクリーニングや前処理の際にぜひ活用してみてください。",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}