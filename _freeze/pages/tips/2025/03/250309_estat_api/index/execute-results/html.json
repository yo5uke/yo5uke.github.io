{
  "hash": "423421679ba69065ddad0b4dc1dbfabc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: e-Stat APIを使ってデータを取得しよう\ndescription: |\n  APIの第一歩についてまとめます！\ndate: 2025-03-09\ndate-modified: 2025-10-23\ncategories:\n- R\n- データ処理\naliases:\n- /pages/tips/250309_estat_api/index.html\n---\n## はじめに\n\n今回は説明するという言い方がおこがましい程度の備忘録的な内容です。\n\n今後データを使う仕事をするにあたり、もう少し統計データに詳しくなりたいと思い、e-Statでよく目にするAPIに目を付けました。正直APIというのが何かわからないレベルからのスタートでしたが、調べながら初歩的な部分をすこーし理解できた気がしないでもありません。\n\n今回はAPIの初歩の初歩をまとめていきたいと思います。\n\n## e-Statでの準備\n\nまずはじめにe-Statでユーザー登録をし、アプリケーションIDを取得する必要があります。\n\nブラウザで[e-Stat](https://www.e-stat.go.jp/)を開き、画面右上の「新規登録」から登録します。難しい点はほとんどないと思うので詳細は省略しますが、登録できたらログインした状態にしておいてください。\n\n![右上の「新規登録」から登録します](image/e-stat_home.png){fig-align=\"center\"}\n\nログインできたら、上部の青いナビゲーションバーに「マイページ」が出てきますので、そこをクリックしてマイページに進みます。\n\nするとナビゲーションバーの少し下に水色のバーが出てきて、そこに「API機能（アプリケーションID発行）」とあるので、そこをクリックします。\n\n![右から2つ目の項目です](image/e-stat_mypage.png){fig-align=\"center\"}\n\nするとアプリケーションIDの取得ということで3つの欄が出てきますので、1番上の欄を使用していきます。名称の部分に任意の名前を入れ、URLはそのままにしておきます。右側の「発行」をクリックすれば「appId」の部分にアプリケーションIDが表示され、これを後ほど使うことになります。\n\n![名称は何でも大丈夫です](image/e-stat_get_appid.png){fig-align=\"center\"}\n\n## 使用するパッケージ\n\nRに戻ります。\n\n今回は以下の3つのパッケージを使用します。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# インストール\n# pak::pak(c(\"httr\", \"xml2\", \"tidyverse\"))\n\nlibrary(httr)\nlibrary(xml2)\nlibrary(tidyverse)\n```\n:::\n\n\n{httr}はHTTPリクエストを送信してWeb APIからデータを取得するためのパッケージで、{xml2}はXMLデータを解析して必要な情報を抽出するためのパッケージです。XMLはデータを構造化して表現するためのフォーマットであり、APIなどでデータを受け取る際によく使われるようです。\n\n{tidyverse}はおなじみのデータハンドリング用です。\n\n## APIでデータを取得\n\n### APIリクエストURLを取得、格納\n\nまずはe-Statで取得したい統計のページへアクセスします。今回は令和2年国勢調査の人口等基本集計、総人口と男女別人口のデータを取得したいと思います。今回使うページのURLは以下です。\n\n<https://www.e-stat.go.jp/stat-search/database?page=1&layout=datalist&toukei=00200521&tstat=000001136464&cycle=0&tclass1=000001136466&statdisp_id=0003445078&tclass2val=0>\n\nページにAPIと書かれた青いアイコンがあるので、そこをクリックします。するとURLが表示されるので、表示されたURLをコピーしておきます。\n\n![左側にあるAPIと書かれた部分をクリックして出てきたURLをコピーします](image/e-stat_api_url.png){fig-align=\"center\"}\n\n次にRで今コピーしたURLを格納します。ダブルクォーテーションで囲んでください。\n\n``` r\nurl <- \"https://api.e-stat.go.jp/rest/3.0/app/getStatsData?appId=&lang=J&statsDataId=0003445078&metaGetFlg=Y&cntGetFlg=N&explanationGetFlg=Y&annotationGetFlg=Y&sectionHeaderFlg=1&replaceSpChars=0\"\n```\n\nここで注意ですが、**URLの中に`appId=`という部分があり、ここに先ほど作成したアプリケーションIDを入れる必要があります**。仮にアプリケーションIDを`123456789`とすると、\n\n``` r\nurl <- \"https://api.e-stat.go.jp/rest/3.0/app/getStatsData?appId=123456789&lang=J&statsDataId=0003445078&metaGetFlg=Y&cntGetFlg=N&explanationGetFlg=Y&annotationGetFlg=Y&sectionHeaderFlg=1&replaceSpChars=0\"\n```\n\nとなります。\n\n`appId`の部分を直接入れ替えることに不安がある方は、以下の方法でも可能です。\n\n``` r\nappId <- \"123456789\"  # ここにアプリケーションIDを入れます\n\n# コピーしてきたURL\nurl_template <- \"https://api.e-stat.go.jp/rest/3.0/app/getStatsData?appId=%s&lang=J&statsDataId=0003445078&metaGetFlg=Y&cntGetFlg=N&explanationGetFlg=Y&annotationGetFlg=Y&sectionHeaderFlg=1&replaceSpChars=0\"\n\nurl <- sprintf(url_template, appId)\n```\n\n`sprintf()`は文字列の中に変数を埋め込む関数です。`%s`の部分が`appId`で置き換えられるようになっています。\n\n\n\n### URLを使ってAPIリクエストを実行\n\n次に入力したURLを使ってAPIリクエストを実行します。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresponse <- GET(url)\n```\n:::\n\n\nこのレスポンスの内容をテキストとして取得し、XMLとして読み込んでいきます。`response`にはステータスコードが含まれているのですが、これが200だと読み込みが成功しています。成功していれば読み込むように設定します。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (status_code(response) == 200) {\n  xml_data <- read_xml(\n    content(response, as = \"text\", encoding = \"UTF-8\")\n  )\n\n  print(xml_data)\n} else {\n  stop(\n    \"データの取得に失敗しました。HTTPステータスコード: \",\n    status_code(response)\n  )\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_document}\n<GET_STATS_DATA noNamespaceSchemaLocation=\"https://api.e-stat.go.jp/rest/3.0/schema/GetStatsData.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n[1] <RESULT>\\n  <STATUS>0</STATUS>\\n  <ERROR_MSG>正常に終了しました。</ERROR_MSG>\\n  <D ...\n[2] <PARAMETER>\\n  <LANG>J</LANG>\\n  <STATS_DATA_ID>0003445078</STATS_DATA_ID ...\n[3] <STATISTICAL_DATA>\\n  <RESULT_INF>\\n    <TOTAL_NUMBER>12258</TOTAL_NUMBER ...\n```\n\n\n:::\n:::\n\n\nステータスコードが200になっていたようなので`{xml_document}`としていろいろ出てきました。また、`xml_data`に読み込んだXMLが保存されています。\n\n### XMLの構造確認\n\n次にXMLの構造を確認してみます。しかしこれは非常に長くなるので、結果は表示しません。実際に手元で実行してみてください。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxml_structure(xml_data)\n```\n:::\n\n\n結果の中には様々な情報が構造化されて格納されていることがわかります。僕たちが抽出したい情報は`{text}`と表示されてしまっているので、このままでは`{text}`が何か確認することができませんが、この中には統計名や更新日など、統計に関する様々な情報（タグ）が含まれます^[[こちら](https://www.e-stat.go.jp/api/api-info/e-stat-manual3-0#api_3_4)からタグの種類を確認できます。]。必要に応じてここから情報を取得することができるので、試しにいろいろやってみましょう。\n\n1.  統計表の名前\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable_name <- xml_text(xml_find_first(xml_data, \"//TABLE_INF/STATISTICS_NAME\"))\nprint(table_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"令和２年国勢調査 人口等基本集計　（主な内容：男女・年齢・配偶関係，世帯の構成，住居の状態，母子・父子世帯，国籍など）\"\n```\n\n\n:::\n:::\n\n\n2.  調査日\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey_date <- xml_text(xml_find_first(xml_data, \"//TABLE_INF/SURVEY_DATE\"))\nprint(survey_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"202010\"\n```\n\n\n:::\n:::\n\n\n3.  統計表の公開日\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopen_date <- xml_text(xml_find_first(xml_data, \"//TABLE_INF/OPEN_DATE\"))\nprint(open_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2021-11-30\"\n```\n\n\n:::\n:::\n\n\nいろいろ結果が出てきました。ここで、使用していた関数について説明します。\n\nまず`xml_text()`です。これはXML内の ノード^[XMLデータの中の要素（タグ）や属性、テキストなどの構成要素のことを言います。]のテキストを取得する関数です。内容をテキストとして抽出するものというようなイメージだと思ってください。\n\n次に`xml_find_first()`です。これは括弧内で指定したパスと合致する最初のものを抽出してくるという関数です。例えば上の1番では、`\"//TABLE_INF/STATISTICS_NAME\"`に一致する部分を探して、そこに書かれている内容を引っ張ってきます。最初ということは複数あるのか？と僕も最初は思ったのですが、どうやら1つしかない要素に対しても一般的に使うようです^[今回取得してきたような要素は全体を見ても1か所にしか出てきません。]。\n\n::: callout-tip\n## XPath（XML上のパス）について\n\nXMLの構造を丁寧に見た方の中には、`TABLE_INF`は実は`GET_STATS_DATA`の中のさらに`STATISTICAL_DATA`の中に入っているがそれは指定しなくてよいのか、と思った方もいるかもしれません。そこは最初の2つのスラッシュ（`//`）で対応していて、これは全体のどこにあっても、例えば`TABLE_INF/STATISTICS_NAME`となっている部分を見つけ出して中身を抽出するということを意味しています。つまり、上記の書き方で`\"/GET_STATS_DATA/STATISTICAL_DATA/TABLE_INF/STATISTICS_NAME\"`をヒットさせることができるわけです。\n:::\n\n### データを取得\n\nではいろいろ確認できたところでデータを取得する作業に入ります。\n\nデータは`//DATA_INF/VALUE`というところに含まれているので、このパスを用います。また構造を確認していただけばわかるように、`VALUE`というのは大量にありますので`xml_find_first()`では最初の1つしか取得できず、不適切です。ここでは`xml_find_all()`ですべての用をを取得していきます。\n\n加えて、\n\n```         \n<VALUE [tab, cat01, area, time, unit]>\n```\n\nとなっているように、`VALUE`には5つの属性が付与されており、それぞれ統計表のタブ（表のバージョンや種類）、統計のカテゴリ、自治体コード、時間（ここでは年）、単位を示します。これを踏まえて必要な情報を以下のコードでは取得しています。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# データがあるノードをすべて取得\nvalue_nodes <- xml_find_all(xml_data, \"//DATA_INF/VALUE\")\n\ndf <- tibble(\n  # xml_attr()で特定の属性を取得\n  area = xml_attr(value_nodes, \"area\"),\n  time = xml_attr(value_nodes, \"time\"),\n  category = xml_attr(value_nodes, \"cat01\"),\n  # valueはテキストとして取得したのち数値に変換\n  value = as.numeric(xml_text(value_nodes))\n)\n\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12,258 × 4\n   area  time       category     value\n   <chr> <chr>      <chr>        <dbl>\n 1 00000 2020000000 0        126146099\n 2 01000 2020000000 0          5224614\n 3 01100 2020000000 0          1973395\n 4 01101 2020000000 0           248680\n 5 01102 2020000000 0           289323\n 6 01103 2020000000 0           265379\n 7 01104 2020000000 0           211835\n 8 01105 2020000000 0           225298\n 9 01106 2020000000 0           135777\n10 01107 2020000000 0           217040\n# ℹ 12,248 more rows\n```\n\n\n:::\n:::\n\n\nこのままだと少しわかりにくいですね。`time`は年なので上4桁だけ取り出したいし、`category`には３つの数字があるのですが、それぞれが何を意味しているのか分かりません。\n\nひとまずカテゴリについて確認しておきましょう。XMLの中に`CLASS_INF`があり、その中に情報が含まれています。カテゴリ（`cat01`がそれです）について知りたい場合は`\"//CLASS_INF/CLASS_OBJ[@id='cat01']/CLASS\"`で確認できます。以下のコードを実行してください。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# xml_data内のノードを取得\ncat01_nodes <- xml_find_all(\n  xml_data,\n  \"//CLASS_INF/CLASS_OBJ[@id='cat01']/CLASS\"\n)\n\n# cat01のコードと対応する名前を取得\ndf_cat01 <- tibble(\n  cat01_code = xml_attr(cat01_nodes, \"code\"),\n  cat01_name = xml_attr(cat01_nodes, \"name\")\n)\n\n# 結果を表示\nprint(df_cat01)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  cat01_code cat01_name\n  <chr>      <chr>     \n1 0          総数      \n2 1          男        \n3 2          女        \n```\n\n\n:::\n:::\n\n\n0が総数、1が男、2が女であることがわかりました。なのでここでカテゴリを書き換え、ついでに年も整理し並べ替えておきましょう。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_cleaned <- df |>\n  arrange(area, time, category) |>\n  mutate(\n    # timeは上4桁を取り出す\n    time = as.integer(substr(time, 1, 4)),\n    # case_when()で条件分岐\n    category = case_when(\n      # 文字列として格納されているので\"\"で囲みます\n      category == \"0\" ~ \"population\",\n      category == \"1\" ~ \"pop_male\",\n      category == \"2\" ~ \"pop_female\"\n    )\n  )\n\nprint(df_cleaned)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12,258 × 4\n   area   time category       value\n   <chr> <int> <chr>          <dbl>\n 1 00000  2020 population 126146099\n 2 00000  2020 pop_male    61349581\n 3 00000  2020 pop_female  64796518\n 4 01000  2020 population   5224614\n 5 01000  2020 pop_male     2465088\n 6 01000  2020 pop_female   2759526\n 7 01100  2020 population   1973395\n 8 01100  2020 pop_male      918682\n 9 01100  2020 pop_female   1054713\n10 01101  2020 population    248680\n# ℹ 12,248 more rows\n```\n\n\n:::\n:::\n\n\nもしカテゴリの各種をそれぞれ列にしたければ`pivot_wider()`でできます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_wide <- df_cleaned |>\n  pivot_wider(\n    names_from = category,\n    values_from = value\n  )\n\nprint(df_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,086 × 5\n   area   time population pop_male pop_female\n   <chr> <int>      <dbl>    <dbl>      <dbl>\n 1 00000  2020  126146099 61349581   64796518\n 2 01000  2020    5224614  2465088    2759526\n 3 01100  2020    1973395   918682    1054713\n 4 01101  2020     248680   112853     135827\n 5 01102  2020     289323   136596     152727\n 6 01103  2020     265379   126023     139356\n 7 01104  2020     211835   100062     111773\n 8 01105  2020     225298   104154     121144\n 9 01106  2020     135777    62347      73430\n10 01107  2020     217040   100027     117013\n# ℹ 4,076 more rows\n```\n\n\n:::\n:::\n\n\nこれでひとまずデータフレームとして整理することができました。ここからさらに整理したり、分析を回していきましょう！\n\n## データベースから取得する\n\n今回は国勢調査のような既にまとめられたデータを用いましたが、e-Statのデータベースを使えば必要なデータを選択して取得することができます。\n\n例えば[こちら](https://www.e-stat.go.jp/regional-statistics/ssdsview)から「市区町村データ」を選択し「データ表示」をクリックします。\n\n出てきた画面から地域を選択し、「確定」をクリックしたのち取得したいデータを選択し、再度「確定」をクリックします。\n\n![地域を選択します](image/e-stat_database_area.png){fig-align=\"center\"}\n\n![取得したい統計項目を選択します](image/e-stat_database_category.png){fig-align=\"center\"}\n\nするとデータが画面に表示されますが、ここで右上の「API」をクリックし、表示されたURLをコピーします。ここからは上で書いてきた手順と同様です。\n\n![URLの使い方はこれまでと同様です](image/e-stat_database_api.png){fig-align=\"center\"}\n\n## おわりに\n\nAPIは正直初心者には難しいなと感じましたが、大体のコードはそのまま使いまわせますし、XMLの構造を少し辛抱して眺めてみればどこに何が入っているのか少しずつわかってきました。\n\nCSVでダウンロードすると余計な情報量が多く分析の手間に感じていましたので、春休みを機に少しではありますが知れてよかったと思います。ぜひ活用してみて下さい。\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}