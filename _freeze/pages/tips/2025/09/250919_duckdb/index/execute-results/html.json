{
  "hash": "4f4465aafadabc6556ad1a8e4d82e49f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 【Python追加】DuckDBをRで使う【[duckplyr]{.fira-code}も】\ndescription: |\n  R上でデータベース操作を行うために、DuckDBを利用する方法についてまとめます。Pythonも追加しました。\ndate: 2025-09-19\ndate-modified: 2026-01-18\ncategories:\n  - R\n  - Python\n  - SQL\n  - データ処理\naliases:\n- /pages/tips/250919_duckdb/index.html\n---\n\n## はじめに\n\nRで大量のデータを扱う際、メモリ制限やパフォーマンスの問題に直面することがあります。そんなとき、軽量で高速な組み込み型のデータベースであるDuckDBを利用することで、効率的にデータ操作が可能になります。本記事では、RでDuckDBを使用する方法について解説します。\n\n:::{.callout-note}\n## 2026/01/17 追記\nPythonでDuckDBを使う方法についても追記しました。RとPythonの両方でDuckDBを活用する方法を紹介しています。\n:::\n\n## DuckDBとは\n\nDuckDBは、組み込み型のSQLデータベースであり、特に分析ワークロードに最適化されています。SQLiteのように軽量でありながら、大規模なデータセットを効率的に処理できる点が特徴です。DuckDBは、列指向ストレージを採用しており、分析クエリのパフォーマンスが向上します。\n\nちなみに組み込み型データベースとは、アプリケーションに組み込まれて動作するデータベースのことを指します。PostgreSQLなどのサーバー型のデータベースとは異なり、外部のデータベースサーバーを必要とせず、アプリケーション内で直接データベース操作が可能です。すなわち**R/Python上で完結する**ということです。\n\n列指向については、ブログでparquetを扱った際に少し触れています。以下もご覧ください。簡潔に言うと、列指向データベースは、データを行ではなく列ごとに格納するため、特定の列に対するクエリが高速に処理されるという特徴があります。\n\n{{< linkcard url=\"/pages/blog/2025/07/250728_parquet/index.qmd\" >}}\n\n## DuckDBのインストール\n\n### Rでのインストール\n\nDuckDBをRで使用するには、`duckdb`パッケージをインストールします。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"pak\")\npak::pak(\"duckdb\")\n```\n:::\n\n\nもしくは\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"duckdb\")\n```\n:::\n\n\n### Pythonでのインストール\n\nDuckDBをPythonで使用するには、`duckdb`パッケージをインストールします。\n\n```python\n# pipを使用する場合\npip install duckdb\n\n# uvを使用する場合\nuv add duckdb\n```\n\nuvについては以下の記事をご参照ください。\n\n{{< linkcard url=\"/pages/tips/2025/09/250926_virtual_environment/index.qmd\" >}}\n\n## DuckDBの基本的な使い方\n\nDuckDBでは、CSVなどのファイルを直接読み込んでSQLクエリを実行したり、RやPythonのデータフレームをデータベースに登録して操作したりすることができます。以下では、RとPythonでの基本的な使い方を紹介します。\n\n### データベースへの接続\n\nまずは、DuckDBデータベースに接続します。DuckDBには**メモリ内データベース**と**永続データベース**の2種類があります。\n\n以下のコードでは、メモリ内データベースに接続していますが、永続データベースを使用することも可能です。\n\n永続データベースではファイルにデータが保存されるため、セッションを終了してもデータが保持されます。新しくセッションを開始した際にも、同じデータベースファイル（`.duckdb`ファイル）に接続してデータを再利用できます。\n\n一方、メモリ内データベースはセッションが終了するとデータが失われてしまいます。必要に応じて使い分けてください。\n\n### Rでの接続例\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(duckdb)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# メモリ内データベースに接続\ncon <- dbConnect(duckdb())\n```\n:::\n\n\n永続データベースに接続する場合は、以下のようにします。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 永続データベースに接続\ncon <- dbConnect(duckdb(), dbdir = here::here(\"data/iris.duckdb\"))\n```\n:::\n\n\nこの方法だと、`data`フォルダに`iris.duckdb`という名前でデータベースファイルが作成されます。`.duckdb`ファイルを置くパスは自由に変更してください。\n\n### Pythonでの接続例\n\nPythonでDuckDBに接続する場合は、以下のようにします。\n\n```python\nimport duckdb\n\n# メモリ内データベースに接続\ncon = duckdb.connect()\n```\n\n```python\n# 永続データベースに接続する場合\ncon = duckdb.connect('data/iris.duckdb')\n```\n\n### データの読み込み\n\n#### SQLを使う場合\n\nDuckDBは様々なデータ形式をサポートしています。ここでは、CSVファイルを読み込む例を示します。\n\n:::{.panel-tabset}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# CSVファイルを読み込む\ndbExecute(con, \"CREATE TABLE iris AS SELECT * FROM read_csv('data/iris.csv')\")\n```\n:::\n\n\n## Python\n\n```python\ncon.sql(\"CREATE TABLE iris AS SELECT * FROM read_csv('data/iris.csv')\")\n```\n:::\n\nさて、ここで突然SQL文が出てきましたが、なんとなく単語を見てもらえればわかる通り、`read_csv('data/iris.csv')`から全ての列を選択（`*`は全ての列を意味します）して、`iris`という名前のテーブルを作成（`CREATE TABLE iris AS`）しています。\n\nここでは**先ほど接続した`con`は使っていない点に注意してください**。この方法を採るメリットは、**R/Pythonに一度もデータを読み込まずに、DuckDBが直接CSVファイルを処理できる**点です。R/Pythonに読み込まれるのはクエリの結果だけなので、メモリ消費を抑えられます。\n\nまた、`CREATE TABLE ... AS SELECT ...`という形で書けば、SQLの標準的な構文で柔軟に前処理（列の選択やフィルタリングなど）を行いながら、テーブルを作成できます。\n\n#### Rを使う場合\n\nSQLになじみがない方にとっては、使い慣れたRのコードでデータベース操作ができると嬉しいと思います。\n\n実はRでDuckDBを使う場合には、今提示したコードを皆さんおなじみ`dplyr`を使って実行できるというメリットがあります！`dplyr`を使って書いたコードをSQLに変換して実行してくれるのです。\n\nデータベースやSQLはなんだかよくわからないけれども、`dplyr`が使えるならうれしいですよね^[ただ、SQLを使う場合のメリットの裏返しで、一度R上でデータを読み込んでからデータベースに送り込むことになるので、メモリを多く消費することと、データが大きいと処理速度が遅くなることには注意してください。]。\n\nその場合のコードを見てみましょう。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # `dplyr`だけでもOKです。\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_data <- read_csv(here::here(\"data/iris.csv\"))\nduckdb_register(con, iris, \"iris_data\")\n```\n:::\n\n\nまずはデータベースに入れたいデータを`read_csv()`で読み込みます。ここでは`data`フォルダにある`iris.csv`を読み込んでいます。\n\n続いて`duckdb_register()`を使って、`iris_data`を`iris`という名前でデータベースに登録しています。これでデータベース上に`iris`テーブルが作成されました。\n\nちなみにファイルベースのデータベースを使いたい場合は、`duckdb_register()`の代わりに`dbWriteTable()`を使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con, \"iris\", iris_data)\n```\n:::\n\n\nこれで`.duckdb`ファイルに`iris`テーブルが保存されます。\n\nちなみに、データベースにはテーブルを複数作成できるので、`iris`以外のデータもも好きな名前でテーブルを追加できます^[とはいえ、プロジェクトごとなどで`.duckdb`は分けた方が良いとは思います。]。\n\n### データの操作\n\nところで、データベースを使うメリットのひとつに、遅延評価（lazy evaluation） があります。これは、実際に結果を取り出すまでSQLが実行されない仕組みのことです。\n\n通常のデータ処理は\n\n```\nデータの読み込み → 書いた順に処理を実行 → 結果を返す\n```\nという流れですが、遅延評価では\n\n```\nデータの読み込み → 書いた順に処理を記録 → 最後にまとめて実行（SQL発行） → 結果を返す\n```\n\nという流れになります。\n\nこのおかげで、大規模なデータセットでも不要な計算が省かれ、効率的に処理できます。\n\n#### SQLを使う場合\n\nSQLを使ってデータを操作する場合、以下のようにクエリを実行します。\n\n:::{.panel-tabset}\n## R\n\n::: {.cell}\n\n```{.r .cell-code}\n# データをクエリする\nresult <- dbGetQuery(con, \"SELECT * FROM iris WHERE Species = 'setosa'\")\n```\n:::\n\n\n## Python\n```python\n# データをクエリする\nresult = con.sql(\"SELECT * FROM iris WHERE Species = 'setosa'\")\n```\n:::\n\nこの例では、`iris`テーブルから`Species`が`setosa`の行を選択しています。\n\n#### `dplyr`を使う場合\n\n`dplyr`を使ってデータを操作する場合、以下のように記述します（おなじみの感じですね）。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- tbl(con, \"iris\") |>\n  filter(Species == \"setosa\") |>\n  collect()\n```\n:::\n\n\n`tbl(con, \"iris\")`でデータベース上の`iris`テーブルを参照し、`filter()`で条件を指定しています。最後に`collect()`を使って結果をRのデータフレームとして取得します。\n\nここで重要なのは、**`collect()`を呼び出すまではSQLは実行されない**という点です。`filter()`などの処理を追加するたびに、裏でSQLクエリが少しずつ組み立てられていき、最後に`collect()`を呼び出した時点でまとめて実行されます。\n\nつまり、`collect()`を呼び出すまではデータはRに読み込まれず、操作はあくまで「SQLを組み立てているだけ」です。`collect()`を実行した瞬間に初めてSQLが発行され、結果がRにデータフレームとして取り込まれます。\n\nデータベースになじみがない方は違和感があるかもしれませんが（かく言う僕もですが）、`con`自体はデータそのものではなく、DuckDBデータベースへの接続（コネクション）を表すオブジェクトです。\n\n普段のRではデータフレームを直接操作しますが、ここではまず接続オブジェクト`con`を通して「このデータベースの中にあるテーブルを参照しますよ」という指示を出します。\n\nつまり、`con`はデータの実体ではなく、**「データベースへの窓口」や「リモコン」**のようなものと考えると分かりやすいです（ChatGPT曰く）。\n\nとりあえず、`collect()`の前までは通常のデータ処理と同じように`dplyr`の関数を使って操作できるので、慣れ親しんだ方法でデータを扱うことができます。\n\n### テーブルの削除\n\n追加したテーブルを削除する場合は、以下のようにします。\n\n:::{.panel-tabset}\n## R\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(con, \"DROP TABLE iris\")\n```\n:::\n\n\n## Python\n```python\ncon.sql(\"DROP TABLE iris\")\n```\n:::\n\nこれで`iris`テーブルがデータベースから削除されます。\n\nもし安全に削除したい場合は、\n\n:::{.panel-tabset}\n## R\n\n::: {.cell}\n\n```{.r .cell-code}\ndbExecute(con, \"DROP TABLE IF EXISTS iris\")\n```\n:::\n\n\n## Python\n```python\ncon.sql(\"DROP TABLE IF EXISTS iris\")\n```\n:::\n\nとすることで、テーブルが存在しない場合でもエラーにならずに処理を続行できます。\n\n### データベースからの切断\n\nデータベースの操作が終わったら、接続を切断します。\n\n:::{.panel-tabset}\n## R\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(con, shutdown = TRUE)\n```\n:::\n\n\n## Python\n```python\ncon.close()\n```\n:::\n\nRで`shutdown = TRUE`を指定すると、メモリ内データベースの場合はデータが消去され、ファイルベースのデータベースの場合は接続が閉じられます。\n\n## {duckplyr}を使う\n\n`duckplyr`パッケージを使うと、DuckDBと`dplyr`の連携がさらに便利になります。`duckplyr`は、DuckDB専用の`dplyr`拡張パッケージであり、DuckDBの機能をより活用できます。\n\n### duckplyrとは\n\n`duckplyr`は、**dplyrのドロップイン置き換え**として機能するパッケージです。既存のdplyrコードをそのまま使いながら、裏側でDuckDBの高速な分析エンジンを活用できます。\n\n### 先述のアプローチとの違い\n\nこれまで紹介してきた`duckdb`パッケージを使った方法と`duckplyr`を使った方法の違いを整理します。\n\n**duckdb × dbplyr（データベース操作）**\n\n```r\nlibrary(dplyr)\nlibrary(DBI)\n\n# データベースに接続\ncon <- dbConnect(duckdb::duckdb())\n\n# データベース上のテーブルを参照\ntbl(con, \"my_table\") |>\n  filter(value > 100) |>\n  summarise(total = sum(value))\n```\n\n- データベースに接続する\n- dplyrの構文を**SQLに翻訳**して実行\n- データは基本的にDB上に存在\n- `collect()`で初めてRのメモリに読み込まれる\n\n**duckplyr（メモリ内データの高速化）**\n\n```r\nlibrary(duckplyr)\n\ndf <- data.frame(x = 1:1000000, y = rnorm(1000000))\n\ndf |>\n  filter(y > 0) |>\n  summarise(mean_x = mean(x))\n```\n\n- **データベース接続不要**\n- Rのメモリ上のデータをDuckDBエンジンで高速処理\n- SQLへ翻訳はされない（データはR上に存在）\n- 既存のdplyrコードがそのまま高速化される\n\n### duckplyrの特徴\n\n1. **ドロップイン置き換え**\n   - `library(duckplyr)`するだけで、多くのdplyr動詞が高速化\n   - 既存のコードを書き換える必要がほとんどない\n2. **自動フォールバック**\n   - duckplyrで対応できない操作は、自動的に通常のdplyrにフォールバック\n   - エラーで止まることなく処理が継続されます\n3. **大規模データに最適**\n   - DuckDBの並列処理エンジンを活用\n   - メモリ効率の良い処理が可能\n4. **互換性**\n   - dplyrの多くの関数に対応\n   - tidyverseエコシステムとシームレスに連携\n\n#### 簡単な使用例\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(duckplyr)\n#> Loading required package: dplyr\n#> ✔ Overwriting dplyr methods with duckplyr methods.\n#> ℹ Turn off with `duckplyr::methods_restore()`.\n\n# 通常のdplyr構文がそのまま使えます\nmtcars |>\n  group_by(cyl) |>\n  summarise(\n    mean_mpg = mean(mpg),\n    mean_hp = mean(hp),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n    cyl mean_mpg mean_hp\n  <dbl>    <dbl>   <dbl>\n1     4     26.7    82.6\n2     6     19.7   122. \n3     8     15.1   209. \n```\n\n\n:::\n:::\n\n\n注意点として、**読み込み順序が重要**です。`library(tidyverse)`の後に`library(duckplyr)`を読み込むことで、dplyrのメソッドがduckplyrで上書きされます。逆の順序で読み込むと、通常のdplyrが優先されてしまいます。\n\n小さいデータだとあまり速さを実感できないかもしれませんが、大きいデータを扱うときに効果を発揮します。\n\n## まとめ\n\n今回は、RとPythonでDuckDBを使用する方法についてまとめました。\n\nDuckDBは軽量で高速な組み込み型データベースであり、大規模なデータセットを効率的に処理できます。RではSQLを直接使う方法と、`dplyr`を使う方法の両方が利用可能であり、遅延評価によりパフォーマンスが向上します。\n\nまた、Rの`duckplyr`パッケージを使うことで、既存の`dplyr`コードをほぼそのまま高速化できるため、データ処理の効率化が図れます。\n\n最近は仕事ででかいデータを扱うことが増えてきたので、今後もDuckDBを活用していきたいと思います（というか活用し始めています）。ぜひお試しあれ。\n\n## 参考\n\n{{< linkcard url=\"https://duckdb.org/docs/stable/clients/python/overview\" >}}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}