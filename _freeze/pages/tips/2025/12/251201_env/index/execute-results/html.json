{
  "hash": "808d99aecbcdc8598753b74932c4855f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"【Windows】RとPostgreSQL中心の環境構築【GISも】\"\ndescription: |\n  データ分析やGIS分析に便利なRとPostgreSQLをWindows環境で使う方法を解説します。WSLを活用した本格的なセットアップも紹介。\ndate: 2025-12-01\ndate-modified: 2025-12-06\ncategories:\n  - R\n  - WSL\n  - Windows\n  - PostgreSQL\n  - GIS\nimage: image/thumbnail.png\n---\n\n:::{.callout-note}\n## データベースについて\n本記事ではデータベースとしてPostgreSQLを使用しますが、DuckDBもおすすめです。DuckDBは組み込み型のデータベースで、RやPythonから簡単に利用でき、大規模データの処理にも適しています。\n\n使い方については[こちらの記事](/pages/tips/2025/09/250919_duckdb/index.qmd)を参照してください。\n:::\n\n## はじめに\n\nデータ分析や統計処理を行う際、RやPythonといったプログラミング言語に加えて、大規模なデータを効率的に管理・処理するためのデータベースが必要になることがあります。特に、**大規模なローデータがあり、そこからさまざまなデータフレームを生成・操作するような場合**、PostgreSQLのような高機能なデータベースが強力な味方になります。\n\n本記事では、Windows環境でWSL（Windows Subsystem for Linux）を活用し、R、PostgreSQLを中心とした開発環境を構築する方法を解説します。WSLを使うことで、Windowsの使いやすさを保ちながら、Linux環境の恩恵を受けられます。\n\n**この記事の対象読者**\n\n- RやPythonでデータ分析を行っている方\n- PostgreSQLを使ったデータ管理に興味がある方\n- WSLを活用した効率的な開発環境を構築したい方\n\n**環境構築の流れ**\n\n1. Windows上でのセットアップ（基本編）\n2. WSL上でのセットアップ（発展編）\n\n初めての方はまずWindows版から試してみて、より本格的な環境が必要になったらWSL版に移行するのがおすすめです。\n\n結構長いページになってしまったので、目次から適宜ジャンプして読んでみてください。\n\nまた、本ページではSQLコードに関してはRを経由した実行方法を中心に解説します。\n\n:::{.callout-note appearance=\"simple\"}\nMacユーザーの方も、PostgreSQLとRの組み合わせは同様に有効ですので、参考にしてみてください。\n:::\n\n:::{.callout-note}\n## 事前準備\n- Windows 11\n- RとIDE（RStudioやPositron等）はインストール済み\n\nであることを前提とします。\n:::\n\n## PostgreSQLとは\n\nPostgreSQLは、オープンソースの高機能なリレーショナルデータベース管理システム（RDBMS）です。「ポストグレス」と読みます^[会社で教えてくださった上司・先輩がポスグレと呼んでいるので、僕もポスグレ呼びをしています。]。\n\n**PostgreSQLの特徴**\n\n- **高い拡張性**: GIS（地理情報システム）に対応したPostGISなど、様々な拡張機能を追加できる\n- **標準SQLへの準拠**: 標準的なSQL構文をサポートし、複雑なクエリも実行可能\n- **豊富なデータ型**: 配列、JSON、幾何データなど、多様なデータ型に対応\n- **トランザクション管理**: データの整合性を保ちながら安全に操作できる\n\n**なぜPostgreSQLを使うのか**\n\nRやPythonだけでもデータ分析は可能ですが、以下のような場面でPostgreSQLが役立ちます：\n\n- メモリに収まりきらない大規模データの処理\n- 複数のプロジェクトで共通のデータソースを利用\n- 空間データ（緯度経度、ポリゴンなど）の効率的な管理と分析\n- 複雑な集計やフィルタリングをSQL側で事前処理\n\n特に、PostGIS拡張を導入すれば、バス停や人口メッシュといった空間データの距離計算やバッファ分析などが高速に実行でき、GIS分析の強力な基盤となります。\n\n## WSLとは\n\nWSL（Windows Subsystem for Linux）は、Windows上でLinux環境をネイティブに実行できる機能です。仮想マシンよりも軽量で、WindowsとLinuxのファイルシステムを相互に利用できるのが特徴です。\n\n### WSLのメリット\n\n- **パッケージ管理が簡単**: `apt`コマンドで必要なソフトウェアを簡単にインストール\n- **再現性の高い環境**: LinuxベースのDockerやサーバー環境と同じOSで作業できる\n- **高いパフォーマンス**: 特にI/O処理やデータベース操作が高速\n- **開発ツールが豊富**: Linux標準のコマンドラインツールをそのまま利用可能\n\n### Windows版とWSL版、どちらを選ぶべき？\n\n**Windows版が向いている場合**\n\n- 初めてPostgreSQLやRを使う方\n- 既存のWindows環境で素早く始めたい\n- GUIツールを中心に使いたい\n\n**WSL版が向いている場合**\n\n- 空間データ分析（PostGISなど）を本格的に行いたい\n- Dockerやサーバー環境との互換性を重視したい\n- コマンドラインでの作業に慣れている、または学びたい\n- より高いパフォーマンスと柔軟性が必要\n\n本記事では両方の方法を紹介しますので、お好みで選んでください。まずはWindows版で試してみて、必要に応じてWSL版に移行するのもよいと思います。\n\n## 1. Windows上でのセットアップ（基本編）\n\nWindows環境で直接PostgreSQL、Rをセットアップする方法を解説します。GUIツールが使いやすく、初めての方にもおすすめです。\n\n### 1.1 PostgreSQLのインストール\n\n#### インストーラーのダウンロード\n\n1. [PostgreSQL公式サイト](https://www.postgresql.org/download/windows/)にアクセス\n2. ページ冒頭にある「Download the installer」をクリック\n3. 最新の安定版（例: PostgreSQL 18）のWindowsインストーラーをダウンロード\n\n#### インストール手順\n\n1. ダウンロードしたインストーラーを実行\n2. インストールウィザードに従って進める\n   - **Installation Directory**：デフォルトのまま（例：`C:\\Program Files\\PostgreSQL\\18`）\n   - **Select Components**：すべてにチェック（PostgreSQL Server、pgAdmin 4、Stack Builder、Command Line Tools）\n   - **Data Directory**: デフォルトのまま\n   - **Password**: スーパーユーザー（postgres）のパスワードを設定^[シンプルなものでもいけます。]\n   - **Port**: デフォルトの`5432`のまま\n   - **Locale**: `[DEFAULT]`または `Japanese, Japan`\n3. インストール完了後、Stack Builderは「Skip」してOK（あるいはキャンセルして終了）\n\n#### 動作確認\n\n![](image/psql.png)\n\nスタートメニューから「SQL Shell (psql)」を起動し、以下を入力：\n\n```bash\nServer [localhost]:  # Enterキーを押す\nDatabase [postgres]:  # Enterキーを押す\nPort [5432]:  # Enterキーを押す\nUsername [postgres]:  # Enterキーを押す\nClient Encoding [SJIS]:  # Enterキーを押す\nユーザー postgres のパスワード:  # 設定したパスワードを入力\n```\n\nパスワード以外は入力しなくて問題ありません！`postgres=#`と表示されれば成功です。以下のコマンドでバージョンを確認できます：\n\n```sql\nSELECT version();\n```\n\n![バージョン確認](image/psql_version.png)\n\n終了する場合は `\\q` と入力してEnterキーを押します。\n\n#### pgAdmin 4の起動\n\nPostgreSQLをGUIで操作できる「pgAdmin 4」も一緒にインストールされています。スタートメニューから「pgAdmin 4」を起動して、データベースの作成やテーブルの確認ができます。\n\n左側のサイドバーにある「Servers」から「PostgreSQL 18」を選択、「Databases」→「postgres」→「Schemas」→「public」→「Tables」でテーブル一覧を確認できますが、今回はR上で操作することもあり、必ずしもpgAdminを使う必要はありません。一時的にGUIで確認したい場合に利用するとよいと思います。\n\n### 1.2 RからPostgreSQLに接続\n\nRからPostgreSQLを操作するには、`RPostgres`パッケージを使います。また、データベース全般の操作には`DBI`パッケージも必要です。\n\n#### パッケージのインストール\n\nRStudioのコンソールで以下を実行：\n\n```r\ninstall.packages(c(\"RPostgres\", \"DBI\"))\n```\n\n#### 接続テスト\n\n以下のコードで接続を確認します：\n\n```r\nlibrary(DBI)\n\n# データベースに接続\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"あなたのパスワード\"\n)\n\n# 接続確認\ndbGetQuery(con, \"SELECT version();\")\n\n# 切断\ndbDisconnect(con)\n```\n\nエラーが出ずに結果が表示されれば成功です。\n\n:::{.callout-important}\n## パスワードの扱いについて\nプロジェクトが個人用であれば問題ありませんが、チーム開発や公開リポジトリでコードを共有する場合、パスワードを直接コードに書くのは避けた方がよいです。\n\nGitを使用している場合、`.Renviron`ファイルをワーキングディレクトリに作成し、以下のように環境変数を設定する方法がおすすめです：\n\n```\nPG_PASSWORD=あなたのパスワード\n```\n\nRコード内では以下のように取得します：\n\n```r\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = Sys.getenv(\"PG_PASSWORD\")\n)\n```\n\n`.Renviron`ファイルはGitで管理しないよう、`.gitignore`に追加しておいてください。公開しては意味がありませんので…。\n\nもしくは`rstudioapi::askForPassword()`関数を使って、実行時にパスワードを入力させる方法もあります。\n\n```r\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = rstudioapi::askForPassword()\n)\n```\n\nこの場合は、コードを共有してもパスワードは含まれません。\n:::\n\n### 1.3 データベースとテーブルの作成\n\n実際にデータベースとテーブルを作成してみます。\n\nRでは`dbExecute()`関数を使ってSQLコマンドを実行できます。SQLコマンドに詳しくない場合は、Rの場合のコードを書いてAIに変換してもらうのがおすすめです（笑）\n\n#### 新しいデータベースの作成\n\n```r\nlibrary(DBI)\n\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"your_password\"\n)\n\n# 新しいデータベースを作成\ndbExecute(con, \"CREATE DATABASE mydb;\")\n\n# 切断\ndbDisconnect(con)\n```\n\n#### 作成したデータベースに接続してテーブルを作成\n\n先ほどは`dbname`に`postgres`を指定しましたが、今回は新しく作成した`mydb`に接続します。\n\n```r\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"mydb\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"あなたのパスワード\"\n)\n\n# テーブルを作成\ndbExecute(con, \"\n  CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    age INTEGER,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  );\n\")\n\n# データを挿入\ndbExecute(con, \"\n  INSERT INTO users (name, age) VALUES\n  ('Alice', 25),\n  ('Bob', 30),\n  ('Charlie', 35);\n\")\n\n# データを確認\ndbGetQuery(con, \"SELECT * FROM users;\")\n\n# 切断\ndbDisconnect(con)\n```\n\n内容は次の通りです。\n\n1. `users`という名前のテーブルを作成\n2. `id`, `name`, `age`, `created_at`の4つのカラムを定義\n    - SERIAL PRIMARY KEY: 自動的に連番が振られる主キー\n    - VARCHAR(100): 文字列（最大100文字）\n    - INTEGER: 整数\n    - TIMESTAMP DEFAULT CURRENT_TIMESTAMP: レコード作成日時（デフォルトで現在時刻が入る）\n3. 3件のサンプルデータを挿入\n    - Alice（25歳）、Bob（30歳）、Charlie（35歳）\n4. 挿入したデータを取得して表示\n\n#### まとめ\n\nここまでで、Windows上でPostgreSQL、R、Pythonの基本的な環境が整いました。\n\n**セットアップした内容**\n\n- PostgreSQLのインストールと動作確認\n- Rのインストールと接続テスト\n- データベースとテーブルの作成\n\n次のセクションでは、より本格的な開発環境を構築するため、WSL上でのセットアップ方法を解説します。\n\n## 2. WSL上でのセットアップ（発展編）\n\n次にWSL（Windows Subsystem for Linux）を使って、より本格的な開発環境を構築します。Linux環境の恩恵を受けながら、Windowsとシームレスに連携できます。\n\n### 2.1 WSLのインストール\n\n#### WSLの有効化\n\nPowerShellを**管理者として**実行し^[右クリックで「管理者として実行」を選択してください。]、以下のコマンドを入力：\n\n```powershell\nwsl --install\n```\n\nインストールが終わると、Linuxディストリビューションのユーザー名とパスワードの作成を求められます。ユーザー名は何でも大丈夫です。パスワードもめちゃくちゃ簡単で問題ありません。\n\nまた、パスワードは**画面上には表示されませんが、ちゃんと入力されています**。慌てて何回も入力しないようにしてください。\n\nこのコマンドで以下が自動的にインストールされます：\n\n- WSL 2\n- Ubuntu（デフォルトのLinuxディストリビューション）\n- 必要な仮想化コンポーネント\n\n#### システムの更新\n\nUbuntu起動後、まずシステムを最新の状態に更新します：\n\n```bash\nsudo apt update\nsudo apt upgrade -y\n```\n\n`sudo`コマンドは管理者権限でコマンドを実行するためのものです。パスワードの入力を求められたら、先ほど設定したパスワードを入力してください。\n\n### 2.2 PostgreSQL 18のインストール（WSL/Ubuntu）\n\nUbuntu標準のリポジトリではPostgreSQLの古いバージョン（現在は16）がインストールされるため、PostgreSQL公式のAptリポジトリを使用して最新版（PostgreSQL 18）をインストールします。\n\n#### PostgreSQL公式リポジトリの設定\n\n最も簡単な方法は、公式の自動設定スクリプトを使用することです：\n\n```bash\n# PostgreSQL公式リポジトリを自動設定\nsudo apt install -y postgresql-common\nsudo /usr/share/postgresql-common/pgdg/apt.postgresql.org.sh\n```\n\nこのスクリプトが自動的にリポジトリ設定とGPGキーのインストールを行います。\n\n#### PostgreSQL 18のインストール\n\nリポジトリの設定が完了したら、PostgreSQL 18をインストールします：\n\n```bash\n# PostgreSQL 18をインストール\nsudo apt install -y postgresql-18 postgresql-client-18\n```\n\n**インストールされる主なパッケージ:**\n- `postgresql-18`: PostgreSQLサーバー本体\n- `postgresql-client-18`: クライアントツール（psqlなど）\n\n#### PostgreSQLサービスの起動\n\n```bash\n# PostgreSQLサービスの起動\nsudo service postgresql start\n```\n\n#### 動作確認\n\n```bash\n# PostgreSQLのバージョンとクラスター状態を確認\npg_lsclusters\n```\n\n出力例：\n```\nVer Cluster Port Status Owner    Data directory              Log file\n18  main    5432 online postgres /var/lib/postgresql/18/main /var/log/postgresql/postgresql-18-main.log\n```\n\nPostgreSQLに接続：\n```bash\n# PostgreSQLユーザーに切り替えて接続\nsudo -u postgres psql\n```\n\n`postgres=#` プロンプトが表示されたら成功です。\n\nバージョンを確認するには続けて以下を実行します：\n\n```sql\nSELECT version();\n```\n\n出力例：\n\n```\nPostgreSQL 18.1 (Ubuntu 18.1-1.pgdg24.04+2) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit\n```\n\n終了する場合は `\\q` と入力します。\n\n#### パスワードの設定\n\nPostgreSQLのスーパーユーザー（postgres）にパスワードを設定します：\n\n```bash\nsudo -u postgres psql\n```\n\n`postgres=#` プロンプトで以下を実行：\n\n```sql\nALTER USER postgres WITH PASSWORD '設定するパスワード';\n\\q\n```\n\n### 2.3 Rのインストール（WSL/Ubuntu）\n\n#### R本体のインストール\n\n最新版のRをインストールするため、CRANのリポジトリを追加します：\n\n```bash\nsudo apt update -qq\n\n# 必要なパッケージをインストール\nsudo apt install --no-install-recommends software-properties-common dirmngr\n\n# CRANのGPGキーを追加\nwget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc\n\n# CRANのリポジトリを追加\nsudo add-apt-repository \"deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/\"\n\n# パッケージリストを更新してRをインストール\nsudo apt install --no-install-recommends r-base -y\n```\n\n#### 動作確認\n\n```bash\nR --version\n```\n\nバージョン情報が表示されればインストール成功です。\n\n#### 必要なシステムライブラリのインストール\n\nRからPostgreSQLに接続するために必要なライブラリをインストール：\n\n```bash\nsudo apt install -y libpq-dev libssl-dev libcurl4-openssl-dev libxml2-dev\n```\n\n### 2.4 RStudio Serverのインストール（WSL/Ubuntu）\n\n#### RStudio Serverのダウンロードとインストール\n\nRStudio Serverの最新バージョンを[RStudio公式サイト](https://posit.co/download/rstudio-server/)から確認し、以下のコマンドでダウンロードとインストールを行います：\n\n```bash\nsudo apt-get install gdebi-core\nwget https://download2.rstudio.org/server/jammy/amd64/rstudio-server-2025.09.2-418-amd64.deb\nsudo gdebi rstudio-server-2025.09.2-418-amd64.deb\n```\n\n#### RStudio Serverの起動\n\n```bash\nsudo rstudio-server start\n```\n\n#### RStudio Serverへのアクセス\n\nブラウザで`localhost:8787`にアクセスし、WSLのユーザー名とパスワードでログインします。\n\nすると、RStudioのウェブインターフェースが表示され、Rの開発環境が利用可能になります。\n\n### 2.5 RからPostgreSQLに接続（WSL）\n\n#### Rの起動とパッケージのインストール\n\nRStudio ServerあるいはVSCodeでWSLに接続^[{{< kbd Ctrl-Shift-P >}}で「wsl: connect to wsl」と検索し選択することで接続できます。]の上Rコンソールを開き、以下を実行：\n\n```r\ninstall.packages(c(\"DBI\", \"RPostgres\"))\n```\n\n#### 接続テスト\n\n```r\nlibrary(DBI)\n\n# データベースに接続\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"あなたのパスワード\"\n)\n\n# 接続確認\ndbGetQuery(con, \"SELECT version();\")\n\n# 切断\ndbDisconnect(con)\n```\n\n### 2.6 データベースとテーブルの作成（WSL）\n\nWindows版と同じ手順でデータベースとテーブルを作成できます。\n\n#### 新しいデータベースの作成\n\n```r\nlibrary(DBI)\n\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"あなたのパスワード\"\n)\n\n# 新しいデータベースを作成\ndbExecute(con, \"CREATE DATABASE mydb;\")\n\n# 切断\ndbDisconnect(con)\n```\n\n#### テーブルの作成とデータ挿入\n\nWindows版と同様に、usersテーブルを作成してみます：\n\n```r\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"mydb\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"あなたのパスワード\"\n)\n\n# テーブルを作成\ndbExecute(con, \"\n  CREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    age INTEGER,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  );\n\")\n\n# データを挿入\ndbExecute(con, \"\n  INSERT INTO users (name, age) VALUES\n  ('Alice', 25),\n  ('Bob', 30),\n  ('Charlie', 35);\n\")\n\n# データを確認\ndbGetQuery(con, \"SELECT * FROM users;\")\n\n# 切断\ndbDisconnect(con)\n```\n\n### 2.7 WSL環境のファイル操作\n\n#### WindowsからWSLのファイルにアクセス\n\nエクスプローラーのアドレスバーに以下を入力：\n\n```\n\\\\wsl$\\Ubuntu\\home\\あなたのユーザー名\n```\n\nこれでWSL内のファイルをWindows側から操作できます。\n\nエクスプローラーのサイドバーの最下部の「Linux」からもアクセス可能です。\n\n### 2.8 WSL環境の便利なTips\n\n#### WSLの再起動\n\nPostgreSQLが動かなくなった場合などは、WSLを再起動してみてください：\n\n```powershell\n# PowerShellで実行\nwsl --shutdown\n```\n\nその後、Ubuntuを再起動してPostgreSQLを起動：\n\n```bash\nsudo service postgresql start\n```\n\n#### VSCodeでPostgreSQLに接続\n\nRの操作自体はRStudio Serverで行ってもVSCodeでも行ってもどちらでもよいのですが、VSCodeにはPostgreSQL拡張機能があり、データベースの管理が便利です。WindowsのようにpgAdminを使えない代わりに、VSCodeのPostgreSQL拡張機能を利用してテーブルリストなどを確認できます。\n\nVSCodeサイドバーの拡張機能から「ms-ossdata.vscode-pgsql」を検索し、インストールしてください。\n\nインストール終了後、サイドバーにPostgreSQLのアイコンが表示されるのでクリックし、「接続」の右にある「新しい接続を追加する」のアイコンから接続情報を入力します。\n\n![VSCode PostgreSQL拡張機能から接続](image/vscode_extension.png)\n\n- サーバー名：localhost\n- ユーザー名：postgres\n- パスワード：設定したパスワード\n- データベース名：（例）mydb\n\n記入したらテスト接続をクリックし、成功すれば保存して接続を選択します。\n\n接続後、サイドバーのPostgreSQLアイコンをクリックすると、データベースやテーブルの一覧が表示されます。「サーバー」→「localhost」→「Dataases」→「mydb」→「Schemas」→「public」→「Tables」でテーブル一覧を確認できます。\n\n新しくテーブルを追加した場合などは、右クリックして「最新の情報に更新」を選択して更新を反映してください。\n\n#### まとめ\n\nここまでで、WSL上でPostgreSQL、Rを使った本格的な開発環境が整いました。\n\n**セットアップした内容**\n\n- WSL 2とUbuntuのインストール\n- PostgreSQLのインストール\n- Rのインストールと接続\n- RStudio Serverの設定\n- データベースとテーブルの作成\n- VSCodeのPostgreSQL拡張機能の利用\n\nここまでで基本的な設定は完了です。次に実際にデータを取り込んで分析を始めてみましょう。\n\n## データを投入する\n\nPostgreSQLにデータを投入する方法はいくつかありますが、Rから直接データフレームをテーブルに書き込む方法が最も簡単です。\n\n1. Rでデータを読み込む（例：CSVファイル）\n2. `dbWriteTable()`関数を使ってデータフレームをPostgreSQLに書き込む\n\n```r\nlibrary(DBI)\n\n# データベースに接続\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"mydb\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"あなたのパスワード\"\n)\n\nlibrary(tidyverse)\n\n# CSVファイルを読み込む\ndata <- read_csv(\"path/to/your/data.csv\")\n\n# データフレームをPostgreSQLに書き込む\ndbWriteTable(con, \"my_table\", data, overwrite = TRUE)\n\n# データを確認\ndbGetQuery(con, \"SELECT * FROM my_table LIMIT 5;\")\n\n# 切断\ndbDisconnect(con)\n```\n\n`dbWriteTable()`がテーブルを作成する関数で、`overwrite = TRUE`オプションを指定すると、既存のテーブルがあれば上書きされます。\n\n`dbGetQuery()`では、`my_table`から最初の5行を取得して表示しています。\n\n## {dbplyr}でPostgreSQLを操作する\n\nRのデータハンドリングではおなじみの`dplyr`パッケージを使って、PostgreSQL上のデータを操作することもできます。データベースを操作するための`dbplyr`パッケージが動いて通常の`dplyr`の文法でSQLクエリを生成してくれます。\n\n`dbplyr`は`dplyr`の依存パッケージであるため、`dplyr`を読み込めば自動的に利用可能です。\n\nデータベース上のテーブルは`tbl()`関数で参照し、`collect()`関数でRのデータフレームとして取得します。\n\n```r\nlibrary(DBI)\nlibrary(dplyr)\n\n# データベースに接続\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"mydb\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"あなたのパスワード\"\n)\n```\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# テーブルを参照\nmy_table <- tbl(con, \"my_table\") |>\n  filter(column_name > 100) |> # 条件でフィルタリング\n  select(column1, column2) # 必要なカラムを選択\n\n# Rのデータフレームとして取得\nresult <- my_table |> collect()\n\n# 結果を表示\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  column1 column2\n  <chr>     <dbl>\n1 B            20\n2 C            30\n```\n\n\n:::\n\n```{.r .cell-code}\n# 切断\ndbDisconnect(con)\n```\n:::\n\n\nこのコードでは、`my_table`テーブルから`column_name`が100より大きい行をフィルタリングし、`column1`と`column2`のカラムだけを選択しています。最後に`collect()`でRのデータフレームとして取得し、表示しています。\n\nこのように通常の`dplyr`の文法でPostgreSQL上のデータを操作できるため、SQLを直接書かなくても高度なデータ操作が可能です。1からSQLを学ばなくてもよいのは大きいですよね！\n\n重要な点は、**`collect()`を呼び出すまでは実際のデータはRに取り込まれず、SQLクエリ^[クエリとは、データベースに対して行う問い合わせや命令のことです。]がデータベース側で実行される**ということです。データベース側で実行されることで大規模データを効率的に処理できます。\n\nまた、注意点として、**`collect()`を呼び出すまでは`dplyr`に含まれる関数しか使うことができず、他のパッケージの関数は使えない**ことが挙げられます。例えば`collect()`前に`pivot_longer()`を使おうとするとエラーになります。これは`tidyr`パッケージの関数だからです。\n\n## GISのためのPostGIS\n\nPostGISは、PostgreSQLの拡張機能で、地理情報システム（GIS）データを扱うための強力なツールです。PostGISを利用することで、空間データの格納、クエリ、解析が可能になります。\n\nここからは、WSL/Ubuntu環境でPostGISをインストールする手順を解説します。\n\n### PostGISのインストール（WSL/Ubuntu）\n\nPostgreSQLにPostGIS拡張を追加するには、以下のコマンドを実行します：\n\n```bash\nsudo apt install postgresql-18-postgis-3 postgresql-18-postgis-3-scripts -y\n```\n\n#### データベースでPostGISを有効化\n\nPostGISをインストールしたら、使用するデータベースでPostGIS拡張を有効にします：\n\n```bash\n# PostgreSQLに接続\nsudo -u postgres psql -d mydb\n```\n\nデータベース内で以下のSQLコマンドを実行：\n\n```sql\n-- PostGIS拡張を有効化\nCREATE EXTENSION postgis;\n\n-- インストールされた拡張を確認\n\\dx\n\n-- PostGISのバージョンを確認\nSELECT PostGIS_version();\n\n-- 終了\n\\q\n```\n\n`\\dx`コマンドで`postgis`が表示されれば、拡張が正常にインストールされています。\n\n記事を書いている時点での最新バージョンは3.6.1です。\n\n```\nmydb=# SELECT PostGIS_version();\n            postgis_version            \n---------------------------------------\n 3.6 USE_GEOS=1 USE_PROJ=1 USE_STATS=1\n```\n\n### RからPostGISを利用する\n\nRからPostGIS機能を使うには、`sf`パッケージが便利です。\n\n#### 必要なパッケージのインストール\n\n```r\ninstall.packages(\"sf\")\n```\n\n#### 空間データの書き込みと読み取り\n\n```r\nlibrary(DBI)\nlibrary(sf)\nlibrary(dplyr)\n\n# データベースに接続\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"mydb\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"設定したパスワード\"\n)\n\n# サンプルの空間データを作成（東京の主要地点）\npoints <- data.frame(\n  name = c(\"東京駅\", \"渋谷駅\", \"新宿駅\"),\n  lon = c(139.7671, 139.7016, 139.7006),\n  lat = c(35.6812, 35.6580, 35.6938)\n)\n\n# sfオブジェクトに変換（EPSG:4326はWGS84座標系）\npoints_sf <- st_as_sf(points, coords = c(\"lon\", \"lat\"), crs = 4326)\n\n# PostGISテーブルとして書き込み\nst_write(points_sf, con, \"stations\", delete_layer = TRUE)\n\n# データを読み取り\nstations <- st_read(con, \"stations\")\nprint(stations)\n\n# 切断\ndbDisconnect(con)\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 3 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 139.7006 ymin: 35.658 xmax: 139.7671 ymax: 35.6938\nGeodetic CRS:  WGS 84\n    name                 geometry\n1 東京駅 POINT (139.7671 35.6812)\n2 渋谷駅  POINT (139.7016 35.658)\n3 新宿駅 POINT (139.7006 35.6938)\n```\n\n\n:::\n:::\n\n\n#### PostGISの空間関数を使う\n\nPostGISには様々な空間分析関数があります。例えば、2点間の距離を計算：\n\n```r\nlibrary(DBI)\n\ncon <- dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"mydb\",\n  host = \"localhost\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"設定したパスワード\"\n)\n\n# 東京駅と渋谷駅の距離を計算（メートル単位）\n# ST_Distance()の前に地理座標系に変換（::geography）\nquery <- \"\n  SELECT \n    a.name AS from_station,\n    b.name AS to_station,\n    ST_Distance(\n      a.geometry::geography,\n      b.geometry::geography\n    ) AS distance_meters\n  FROM stations a, stations b\n  WHERE a.name = '東京駅' AND b.name = '渋谷駅';\n\"\n\nresult <- dbGetQuery(con, query)\nprint(result)\n\ndbDisconnect(con)\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  from_station to_station distance_meters\n1       東京駅     渋谷駅        6464.826\n```\n\n\n:::\n:::\n\n\nQuery内ではSQL文を書き、`ST_Distance()`関数を使って2つの地点間の距離を計算しています。`::geography`キャストを使うことで、地理座標系での正確な距離計算が可能になります。\n\n#### PostGISの便利な関数\n\nPostGISには多数の空間関数があります。代表的なものを紹介します：\n\n- `ST_Distance()`: 2つのジオメトリ間の距離を計算\n- `ST_Buffer()`: 指定した距離のバッファ（緩衝地帯）を作成\n- `ST_Intersects()`: 2つのジオメトリが交差するかを判定\n- `ST_Within()`: あるジオメトリが別のジオメトリ内に含まれるかを判定\n- `ST_Area()`: ポリゴンの面積を計算\n- `ST_Length()`: ラインの長さを計算\n\nこれらの関数を組み合わせることで、複雑な空間分析が可能になります。\n\n### PostGISのまとめ\n\nPostGISを使うことで、PostgreSQL上で以下のような空間データ分析が可能になります：\n\n- 緯度経度データの格納と管理\n- 点・線・ポリゴンなどの幾何データの操作\n- 距離計算、バッファ分析、空間結合\n- 大規模な空間データの効率的な処理\n\n特に、メモリに収まりきらない大規模な空間データを扱う場合、PostGISは非常に強力なツールとなります。\n\n## おわりに\n\n本記事では、Windows環境でRとPostgreSQLを中心とした開発環境を構築する方法を、Windows版とWSL版の2つのアプローチでまとめました。\n\n**Windows版の特徴**\n\n- GUIツールが使いやすく、初心者にも優しい\n- インストールが簡単で、すぐに始められる\n- pgAdmin 4でデータベースを視覚的に管理可能\n\n**WSL版の特徴**\n\n- Linux環境の恩恵を受けられる\n- aptパッケージマネージャーでPostGISなどの拡張機能を簡単にインストール可能\n- Dockerやサーバー環境との互換性が高い\n- 高速なI/O処理とデータベース操作\n\nどちらの環境でも、RからPostgreSQLを操作する基本的な手順は同じです。まずはWindows版で試してみて、必要に応じてWSL版に移行するのがおすすめです。\n\nPostgreSQLとPostGISを活用することで、大規模データの管理や空間データの高度な分析が可能になります。ぜひ実際のプロジェクトで活用してみてください。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}