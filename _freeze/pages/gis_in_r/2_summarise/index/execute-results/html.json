{
  "hash": "c2a65803dd48f97e1647e85ea1c04cb9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"地理データを集約\"\ndate: 2025-02-21\neditor: visual\n---\n\n## はじめに\n\n今回は地理データを集約する方法について説明します。\n\n集約とは、例えば市町村単位のデータを県単位のデータにまとめるというイメージです。市町村単位のデータしかもっていないものの都道府県単位でプロットしたいといった場合に、今回説明する方法を使えば対応することができます。\n\n## 使用するパッケージ・データ\n\n今回は使用するデータを軽量化するために、イントロで使用した福島県のデータを使います[^1]。日本の全市町村のような場合でも同様の流れで進めることができます。\n\n[^1]: [導入 + ハンドリング](../1_intro/index.html)に出典も示しています。\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # データハンドリング\nlibrary(here)       # 相対パスを使用\nlibrary(sf)         # 地理データを使用\n\n# 福島県のデータの読み込み\nfukushima <- read_sf(here(\"data/N03-20240101_07_GML/N03-20240101_07.shp\"))\n```\n:::\n\n## データの確認\n\nデータのCRS（座標参照系）はデータを読み込んだら確認しておくようにしましょう。これがデータごとに異なるとデータ間で整合性が失われたり、同じデータでも思ったプロットにならなかったりします。\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(fukushima)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: JGD2011 \n  wkt:\nGEOGCRS[\"JGD2011\",\n    DATUM[\"Japanese Geodetic Datum 2011\",\n        ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"Japan - onshore and offshore.\"],\n        BBOX[17.09,122.38,46.05,157.65]],\n    ID[\"EPSG\",6668]]\n```\n\n\n:::\n:::\n\n2行目に`JGD2011`、1番下に`ID[\"EPSG\",6668]]`と書かれています。`6668`は`JGD2011`に対応する数字であり、他の数字であっても1対１の関係で数字が割り振られています。JGD2011は日本測地系2011を表しているのですが、CRSの詳細は次回に回します。\n\nひとまずここでは問題ないので、データの中身を確認したいと思います。\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_voh5w830b7oqvn0n8th5(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_voh5w830b7oqvn0n8th5\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_voh5w830b7oqvn0n8th5');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_voh5w830b7oqvn0n8th5(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_voh5w830b7oqvn0n8th5\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 0, j: 0 }, { i: 0, j: 1 }, { i: 0, j: 2 }, { i: 0, j: 3 }, { i: 0, j: 4 }, { i: 0, j: 5 }, { i: 0, j: 6 },  ], css_id: 'tinytable_css_uujc3z60bhlayfavunrp',}, \n          { positions: [ { i: 6, j: 0 }, { i: 6, j: 1 }, { i: 6, j: 2 }, { i: 6, j: 3 }, { i: 6, j: 4 }, { i: 6, j: 5 }, { i: 6, j: 6 },  ], css_id: 'tinytable_css_46mi7w4mev8gyipp3fnq',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_voh5w830b7oqvn0n8th5(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_uujc3z60bhlayfavunrp, .table th.tinytable_css_uujc3z60bhlayfavunrp { border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; }\n      .table td.tinytable_css_46mi7w4mev8gyipp3fnq, .table th.tinytable_css_46mi7w4mev8gyipp3fnq { border-bottom: solid #d3d8dc 0.1em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_voh5w830b7oqvn0n8th5\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">N03_001</th>\n                <th scope=\"col\">N03_002</th>\n                <th scope=\"col\">N03_003</th>\n                <th scope=\"col\">N03_004</th>\n                <th scope=\"col\">N03_005</th>\n                <th scope=\"col\">N03_007</th>\n                <th scope=\"col\">geometry</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>福島県</td>\n                  <td>NA</td>\n                  <td>NA</td>\n                  <td>福島市</td>\n                  <td>NA</td>\n                  <td>07201</td>\n                  <td>POLYGON ((140.3745 37.65095...</td>\n                </tr>\n                <tr>\n                  <td>福島県</td>\n                  <td>NA</td>\n                  <td>NA</td>\n                  <td>会津若松市</td>\n                  <td>NA</td>\n                  <td>07202</td>\n                  <td>POLYGON ((139.949 37.33309,...</td>\n                </tr>\n                <tr>\n                  <td>福島県</td>\n                  <td>NA</td>\n                  <td>NA</td>\n                  <td>郡山市</td>\n                  <td>NA</td>\n                  <td>07203</td>\n                  <td>POLYGON ((140.1249 37.33085...</td>\n                </tr>\n                <tr>\n                  <td>福島県</td>\n                  <td>NA</td>\n                  <td>NA</td>\n                  <td>いわき市</td>\n                  <td>NA</td>\n                  <td>07204</td>\n                  <td>POLYGON ((140.8494 36.9161,...</td>\n                </tr>\n                <tr>\n                  <td>福島県</td>\n                  <td>NA</td>\n                  <td>NA</td>\n                  <td>いわき市</td>\n                  <td>NA</td>\n                  <td>07204</td>\n                  <td>POLYGON ((140.889 36.91886,...</td>\n                </tr>\n                <tr>\n                  <td>福島県</td>\n                  <td>NA</td>\n                  <td>NA</td>\n                  <td>いわき市</td>\n                  <td>NA</td>\n                  <td>07204</td>\n                  <td>POLYGON ((140.8873 36.91099...</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n\n:::\n:::\n\n1列目に県名、4列目に市町村名、6列目に市町村コード、7列目に座標データが入っているのが確認できます。\n\n次にプロットして確認します。\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = fukushima) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\nこのように市町村の境界が示されています。\n\n今回の目標はこれを県でまとめることなので、最終的に県境だけが残ることになります。\n\n## データの集約\n\nそれでは本題のデータの集約に入ります。\n\nこれまでTidyverseを使ったことがある方であれば、`dplyr::summarise()`が思い浮かぶ方がいらっしゃるのではないでしょうか。特定のグループごとに平均や合計を集計する際に便利な関数ですが、基本的な概念はそれと同じです。\n\n平均を算出する場合であれば`mean()`を使いますが、地理データをまとめる際には`sf`パッケージの`st_union()`を用います。\n\n早速使い方を見てみると、\n\n::: {.cell}\n\n```{.r .cell-code}\nfukushima_summarise <- fukushima |> \n  summarise(geometry = st_union(geometry), \n            .by = N03_001)\n\n# 先にgroup_by()をしても同じ\n# fukushima_summarise <- fukushima |> \n#   group_by(N03_001) |> \n#   summarise(geometry = st_union(geometry))\n```\n:::\n\nこのように、県を表す変数でグルーピングした上で`geometry`を上書きするような形になります。県番号のような、グループを識別できる変数があればそれを用いてもよいのですが、今回は県名しかないので、それを利用しています。\n\nコードにもコメントアウトして書いているように、`group_by()`は先に実行しても問題ありません。`summarise()`内の`.by`は、`group_by()`を指定しているのと同様です。\n\n## 集約したデータの確認\n\n`fukushima_summarise`を確認してみると、1つの行にまとまっていることがわかります。\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<!-- preamble start -->\n\n    <script>\n\n      function styleCell_4s567kwx2nykoeq0izrz(i, j, css_id) {\n          var table = document.getElementById(\"tinytable_4s567kwx2nykoeq0izrz\");\n          var cell = table.rows[i]?.cells[j];  // Safe navigation to avoid errors\n          if (cell) {\n              console.log(`Styling cell at (${i}, ${j}) with class ${css_id}`);\n              cell.classList.add(css_id);\n          } else {\n              console.warn(`Cell at (${i}, ${j}) not found.`);\n          }\n      }\n      function insertSpanRow(i, colspan, content) {\n        var table = document.getElementById('tinytable_4s567kwx2nykoeq0izrz');\n        var newRow = table.insertRow(i);\n        var newCell = newRow.insertCell(0);\n        newCell.setAttribute(\"colspan\", colspan);\n        // newCell.innerText = content;\n        // this may be unsafe, but innerText does not interpret <br>\n        newCell.innerHTML = content;\n      }\n      function spanCell_4s567kwx2nykoeq0izrz(i, j, rowspan, colspan) {\n        var table = document.getElementById(\"tinytable_4s567kwx2nykoeq0izrz\");\n        const targetRow = table.rows[i];\n        const targetCell = targetRow.cells[j];\n        for (let r = 0; r < rowspan; r++) {\n          // Only start deleting cells to the right for the first row (r == 0)\n          if (r === 0) {\n            // Delete cells to the right of the target cell in the first row\n            for (let c = colspan - 1; c > 0; c--) {\n              if (table.rows[i + r].cells[j + c]) {\n                table.rows[i + r].deleteCell(j + c);\n              }\n            }\n          }\n          // For rows below the first, delete starting from the target column\n          if (r > 0) {\n            for (let c = colspan - 1; c >= 0; c--) {\n              if (table.rows[i + r] && table.rows[i + r].cells[j]) {\n                table.rows[i + r].deleteCell(j);\n              }\n            }\n          }\n        }\n        // Set rowspan and colspan of the target cell\n        targetCell.rowSpan = rowspan;\n        targetCell.colSpan = colspan;\n      }\n      // tinytable span after\n      window.addEventListener('load', function () {\n          var cellsToStyle = [\n            // tinytable style arrays after\n          { positions: [ { i: 0, j: 0 }, { i: 0, j: 1 },  ], css_id: 'tinytable_css_ywts3r2l16eq27j1jtlg',}, \n          { positions: [ { i: 1, j: 0 }, { i: 1, j: 1 },  ], css_id: 'tinytable_css_i30nwabcy9qw9osit3o9',}, \n          ];\n\n          // Loop over the arrays to style the cells\n          cellsToStyle.forEach(function (group) {\n              group.positions.forEach(function (cell) {\n                  styleCell_4s567kwx2nykoeq0izrz(cell.i, cell.j, group.css_id);\n              });\n          });\n      });\n    </script>\n\n    <style>\n      /* tinytable css entries after */\n      .table td.tinytable_css_ywts3r2l16eq27j1jtlg, .table th.tinytable_css_ywts3r2l16eq27j1jtlg { border-top: solid #d3d8dc 0.1em; border-bottom: solid #d3d8dc 0.05em; }\n      .table td.tinytable_css_i30nwabcy9qw9osit3o9, .table th.tinytable_css_i30nwabcy9qw9osit3o9 { border-bottom: solid #d3d8dc 0.1em; }\n    </style>\n    <div class=\"container\">\n      <table class=\"table table-borderless\" id=\"tinytable_4s567kwx2nykoeq0izrz\" style=\"width: auto; margin-left: auto; margin-right: auto;\" data-quarto-disable-processing='true'>\n        <thead>\n        \n              <tr>\n                <th scope=\"col\">N03_001</th>\n                <th scope=\"col\">geometry</th>\n              </tr>\n        </thead>\n        \n        <tbody>\n                <tr>\n                  <td>福島県</td>\n                  <td>MULTIPOLYGON (((141.0231 37...</td>\n                </tr>\n        </tbody>\n      </table>\n    </div>\n<!-- hack to avoid NA insertion in last line -->\n```\n\n:::\n:::\n\nさらにこれをプロットしてみると、\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = fukushima_summarise) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nこのように、市境がなくなり、県境のみが残っています。\n\n今は1つの県のみを用いていますが、全国のデータを用いた場合でも、都道府県ごとに`group_by()`されますので、都道府県単位のプロットに集約することが可能です。\n\n## おわりに\n\n今回は`summarise()`と`st_union()`を用いて地理データを集約する方法を説明しました。\n\n市町村を都道府県単位にする以外にも、政令指定都市が区単位になっているので市単位にしたい、と言った場合にも応用することができます。\n\nそういった場合には[Tipsページ](../../tips/240414_benri_seirei/#政令指定都市の区単位のデータ)でご紹介したデータフレームを用い、政令指定都市の区コードを市町村コードに書き換えた後で今回と同じ工程を踏めば、まとめることができます。\n\nぜひご活用ください。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}